"use client";

import React from "react";
import { getAuthToken } from "@/lib/auth";
import Spinner from "@/components/ui/spinner";
import MessageBubble from "@/components/chat/MessageBubble";
// chat: disable snackbars in-chat — use console.debug for non-intrusive messages
import {
  Smile,
  Paperclip,
  Send,
  MoreVertical,
  ArrowLeft,
  Filter,
  Zap,
  Sparkles,
  FileText,
  MessageSquare,
  CheckCheck,
  Check,
} from "lucide-react";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

type Sender = "admin" | "alumno" | "coach";

type Attachment = {
  id: string;
  name: string;
  mime: string;
  size: number;
  data_base64: string;
  url?: string;
  created_at?: string;
};

type Message = {
  id: string;
  room: string;
  sender: Sender;
  text: string;
  at: string;
  attachments?: Attachment[];
  status?: string;
  phase?: string;
  delivered?: boolean;
  read?: boolean;
  srcParticipantId?: string | number;
};

type Transport = "ws" | "local" | "sse" | "socketio";

type SocketIOChatOptions = {
  url?: string;
  /** Token JWT del sistema de auth; si no se pasa, se usará el de auth local */
  token?: string;
  participants?: Array<any>;
  idCliente?: number | string;
  idEquipo?: number | string;
  autoCreate?: boolean;
  autoJoin?: boolean;
  chatId?: number | string;
};

type TicketType =
  | "tecnico"
  | "academico"
  | "administrativo"
  | "soporte"
  | "consulta"
  | "otro";

export default function ChatRealtime({
  room,
  role = "admin",
  title = "Chat",
  subtitle,
  showRoleSwitch = false,
  variant = "card",
  className,
  transport = "ws",
  onBack,
  showGenerateTicket = true,
  showFilter = true,
  showSelect = true,
  socketio,
  onConnectionChange,
  onChatInfo,
  onChatsList,
  requestListSignal,
  listOnConnect = false,
  showTypingIndicator = true,
  showReadControls = false,
  // listParams: payload opcional para chat.list (e.g., { participante_tipo, id_cliente|id_equipo })
  listParams,
}: {
  room: string;
  role?: Sender;
  title?: string;
  subtitle?: string;
  showRoleSwitch?: boolean;
  variant?: "card" | "fullscreen";
  className?: string;
  transport?: Transport;
  onBack?: () => void;
  showGenerateTicket?: boolean;
  showFilter?: boolean;
  showSelect?: boolean;
  socketio?: SocketIOChatOptions;
  onConnectionChange?: (connected: boolean) => void;
  onChatInfo?: (info: {
    chatId: number | string | null;
    myParticipantId: number | string | null;
    participants?: any[] | null;
  }) => void;
  onChatsList?: (list: any[]) => void;
  requestListSignal?: number;
  listOnConnect?: boolean;
  showTypingIndicator?: boolean;
  showReadControls?: boolean;
  listParams?: any;
}) {
  const normRoom = React.useMemo(
    () => (room || "").trim().toLowerCase(),
    [room]
  );
  const [currentRole, setCurrentRole] = React.useState<Sender>(role);
  const [items, setItems] = React.useState<Message[]>([]);
  const [text, setText] = React.useState("");
  const [filterOpen, setFilterOpen] = React.useState(false);
  const [statusFilter, setStatusFilter] = React.useState<string | null>(null);
  const [phaseFilter, setPhaseFilter] = React.useState<string | null>(null);
  const statusOptions = ["EN_CURSO", "COMPLETADO", "ABANDONO", "PAUSA"];
  const phaseOptions = ["ONBOARDING", "F1", "F2", "F3", "F4", "F5"];

  const [ticketModalOpen, setTicketModalOpen] = React.useState(false);
  const [ticketTitle, setTicketTitle] = React.useState("");
  const [ticketDescription, setTicketDescription] = React.useState("");
  const [ticketType, setTicketType] = React.useState<TicketType | "">("");
  const [ticketAutoGenerated, setTicketAutoGenerated] = React.useState(false);
  const [ticketSelectedMessages, setTicketSelectedMessages] = React.useState<
    Message[]
  >([]);
  const [ticketAttachments, setTicketAttachments] = React.useState<
    Attachment[]
  >([]);

  const filteredItems = React.useMemo(() => {
    return items.filter((m) => {
      let ok = true;
      if (statusFilter && m.status) {
        ok = ok && m.status === statusFilter;
      }
      if (phaseFilter && m.phase) {
        ok = ok && m.phase === phaseFilter;
      }
      return ok;
    });
  }, [items, statusFilter, phaseFilter]);

  const wsRef = React.useRef<WebSocket | null>(null);
  const sioRef = React.useRef<any | null>(null);
  const bcRef = React.useRef<BroadcastChannel | null>(null);
  const esRef = React.useRef<EventSource | null>(null);
  const pendingRef = React.useRef<any[]>([]);
  const seenRef = React.useRef<Set<string>>(new Set());
  const bottomRef = React.useRef<HTMLDivElement | null>(null);
  const scrollRef = React.useRef<HTMLDivElement | null>(null);
  const pinnedToBottomRef = React.useRef<boolean>(true);
  const fileRef = React.useRef<HTMLInputElement | null>(null);
  const inputRef = React.useRef<HTMLTextAreaElement | null>(null);
  const [connected, setConnected] = React.useState(false);
  const WS_OPEN = typeof WebSocket !== "undefined" ? WebSocket.OPEN : 1;

  // Estado específico de Socket.IO
  const [chatId, setChatId] = React.useState<number | string | null>(null);
  const [myParticipantId, setMyParticipantId] = React.useState<
    number | string | null
  >(null);
  const [otherTyping, setOtherTyping] = React.useState<boolean>(false);
  const otherTypingTimerRef = React.useRef<any>(null);
  const lastReadEmitRef = React.useRef<number>(0);
  const createdRef = React.useRef<boolean>(false);
  const joinedRef = React.useRef<boolean>(false);
  const listOnceRef = React.useRef<boolean>(false);
  // Mantener una referencia estable de los participantes para evitar re-ejecuciones por identidad del array
  const participantsRef = React.useRef<any[] | undefined>(undefined);
  const participantsKey = React.useMemo(() => {
    try {
      return JSON.stringify(socketio?.participants ?? null);
    } catch {
      return "null";
    }
  }, [socketio?.participants]);
  React.useEffect(() => {
    participantsRef.current = Array.isArray(socketio?.participants)
      ? socketio?.participants
      : undefined;
  }, [participantsKey]);

  const [isJoining, setIsJoining] = React.useState<boolean>(false);
  // Recordar el último id_participante usado para enviar (para clasificar el eco como "mío" si aún no hay myParticipantId)
  const lastSentParticipantIdRef = React.useRef<any>(null);
  // Guardar últimos participantes recibidos en join/create para resoluciones posteriores
  const joinedParticipantsRef = React.useRef<any[]>([]);
  // Evitar dobles creaciones al enviar por primera vez
  const creatingRef = React.useRef<boolean>(false);
  // Evitar dobles joins cuando cambia chatId o al montar
  const joinInFlightRef = React.useRef<boolean>(false);
  const lastJoinedChatIdRef = React.useRef<any>(null);
  // Throttles para list/enrich
  const lastListRefreshAtRef = React.useRef<number>(0);
  const lastEnrichAtRef = React.useRef<number>(0);
  // Mantener refs de autoJoin/chatId para abortar detecciones si cambian
  const latestAutoJoinRef = React.useRef<boolean>(socketio?.autoJoin ?? true);
  const latestChatIdRef = React.useRef<any>(socketio?.chatId ?? null);
  React.useEffect(() => {
    latestAutoJoinRef.current = socketio?.autoJoin ?? true;
  }, [socketio?.autoJoin]);
  React.useEffect(() => {
    latestChatIdRef.current = socketio?.chatId ?? null;
  }, [socketio?.chatId]);
  // Identificador de sesión para ignorar ecos propios en eventos sin emisor explícito
  const clientSessionRef = React.useRef<string>(
    `sess-${Math.random().toString(36).slice(2, 10)}-${Date.now()}`
  );

  // Trackear última solicitud de chatId para evitar remounts innecesarios
  const prevRequestedChatIdRef = React.useRef<any>(null);
  // Outbox local para reconciliar mensajes optimistas con acks entrantes
  const outboxRef = React.useRef<
    Array<{ clientId: string; text: string; at: number; pid?: any }>
  >([]);

  // Mapea el campo archivo/archivos del backend al arreglo de adjuntos del UI
  function mapArchivoToAttachments(src: any): Attachment[] | undefined {
    try {
      const one = src?.archivo ?? src?.Archivo ?? null;
      const many = src?.archivos ?? src?.Archivos ?? null;
      const list = Array.isArray(many) ? many : one ? [one] : [];
      const atts: Attachment[] = [];
      for (const it of list) {
        if (!it) continue;
        atts.push({
          id: String(
            it?.id_archivo ?? it?.id ?? `${Date.now()}-${Math.random()}`
          ),
          name: String(it?.nombre_archivo ?? it?.nombre ?? "archivo"),
          mime: String(it?.mime_type ?? it?.mime ?? "application/octet-stream"),
          size: Number(it?.tamano_bytes ?? it?.size ?? 0),
          data_base64: String(it?.contenido_base64 ?? ""),
          url: it?.url ?? undefined,
          created_at: it?.created_at ?? it?.fecha_creacion ?? undefined,
        });
      }
      return atts.length ? atts : undefined;
    } catch {
      return undefined;
    }
  }

  // Normalización de tipo de participante proveniente del backend
  function normalizeTipo(raw: any): "cliente" | "equipo" | "admin" | "" {
    const v = String(raw || "")
      .trim()
      .toLowerCase();
    if (!v) return "";
    if (["cliente", "alumno", "student"].includes(v)) return "cliente";
    if (["equipo", "coach", "entrenador"].includes(v)) return "equipo";
    if (["admin", "administrador"].includes(v)) return "admin";
    return "";
  }
  // Buscar tipo por id_chat_participante usando los participantes del último join
  function getTipoByParticipantId(
    idChatParticipante: any
  ): "cliente" | "equipo" | "admin" | "" {
    const idStr = String(idChatParticipante ?? "");
    if (!idStr) return "";
    const list = Array.isArray(joinedParticipantsRef.current)
      ? joinedParticipantsRef.current
      : [];
    const found = list.find(
      (p) => String(p?.id_chat_participante ?? "") === idStr
    );
    return normalizeTipo(found?.participante_tipo);
  }

  // Asignar mi id de participante desde una lista de participantes
  function assignMyParticipantIdFromList(
    participants: any[] | undefined | null
  ) {
    try {
      const list = Array.isArray(participants) ? participants : [];
      joinedParticipantsRef.current = list;
      let mine: any = null;
      if (currentRole === "alumno") {
        if (socketio?.idCliente != null) {
          mine = list.find(
            (p) =>
              normalizeTipo(p?.participante_tipo) === "cliente" &&
              String(p?.id_cliente) === String(socketio?.idCliente)
          );
        }
        if (!mine) {
          const clientes = list.filter(
            (p) => normalizeTipo(p?.participante_tipo) === "cliente"
          );
          // Solo asignar por unicidad, nunca elegir arbitrariamente si hay varios clientes
          if (clientes.length === 1) mine = clientes[0];
        }
      } else if (currentRole === "coach") {
        if (socketio?.idEquipo != null) {
          mine = list.find(
            (p) =>
              normalizeTipo(p?.participante_tipo) === "equipo" &&
              String(p?.id_equipo) === String(socketio?.idEquipo)
          );
        }
        if (!mine) {
          const equipos = list.filter(
            (p) => normalizeTipo(p?.participante_tipo) === "equipo"
          );
          // Solo asignar por unicidad, nunca elegir arbitrariamente si hay varios equipos
          if (equipos.length === 1) mine = equipos[0];
        }
      }
      if (mine?.id_chat_participante != null) {
        setMyParticipantId(mine.id_chat_participante);
      }
    } catch {}
  }

  // Claves para comparar grupos de participantes (para evitar duplicados)
  function participantKey(p: any): string {
    const tipo = normalizeTipo(p?.participante_tipo || p?.tipo);
    let id = "";
    if (tipo === "cliente") id = String(p?.id_cliente ?? "");
    else if (tipo === "equipo") id = String(p?.id_equipo ?? "");
    else id = String(p?.id ?? "");
    return `${tipo}:${id}`;
  }
  function buildKeySetFromArray(arr: any[] | null | undefined): Set<string> {
    const list = Array.isArray(arr) ? arr : [];
    const keys = list
      .map((p) => participantKey(p))
      .filter((k) => !!k && !k.startsWith(":"));
    return new Set(keys);
  }
  function equalKeySets(a: Set<string>, b: Set<string>): boolean {
    if (a.size !== b.size) return false;
    for (const k of a) if (!b.has(k)) return false;
    return true;
  }
  function isSubsetSet(a: Set<string>, b: Set<string>): boolean {
    // ¿a ⊆ b?
    for (const k of a) if (!b.has(k)) return false;
    return true;
  }

  const listParamsRef = React.useRef<any>({});

  // Mantener listParams estable via ref para evitar re-renders que disparen list
  React.useEffect(() => {
    listParamsRef.current =
      listParams && typeof listParams === "object" ? { ...listParams } : {};
  }, [listParams]);

  // Notificar cambios de conexión al padre si lo pide
  React.useEffect(() => {
    try {
      onConnectionChange?.(connected);
    } catch {}
  }, [connected]);

  // Notificar info del chat (chatId/mi participante)
  React.useEffect(() => {
    try {
      onChatInfo?.({
        chatId,
        myParticipantId,
        participants: joinedParticipantsRef.current || null,
      });
    } catch {}
  }, [chatId, myParticipantId]);

  const storageKey = React.useMemo(() => `localChat:${normRoom}`, [normRoom]);
  const lastReadKey = React.useMemo(
    () => `chatLastRead:${normRoom}:${currentRole}`,
    [normRoom, currentRole]
  );

  // Guardar lectura por chatId para que la bandeja pueda calcular no leídos
  const markReadByChatId = React.useCallback(() => {
    try {
      if (chatId == null) return;
      const key = `chatLastReadById:${currentRole}:${String(chatId)}`;
      localStorage.setItem(key, Date.now().toString());
      // Reiniciar contador persistente de no leídos por chatId (si existe)
      try {
        const unreadKey = `chatUnreadById:${currentRole}:${String(chatId)}`;
        localStorage.setItem(unreadKey, "0");
        // Notificar cambio de contador para UIs que lean desde localStorage
        window.dispatchEvent(
          new CustomEvent("chat:unread-count-updated", {
            detail: { chatId, role: currentRole, count: 0 },
          })
        );
      } catch {}
      // Notificar en este mismo tab (storage no se dispara en la misma pestaña)
      try {
        window.dispatchEvent(
          new CustomEvent("chat:last-read-updated", {
            detail: { chatId, role: currentRole, at: Date.now() },
          })
        );
      } catch {}
    } catch {}
  }, [chatId, currentRole]);

  const markRead = React.useCallback(() => {
    try {
      localStorage.setItem(lastReadKey, Date.now().toString());
      localStorage.setItem(
        "chatLastReadPing",
        `${normRoom}:${currentRole}:${Date.now()}`
      );
      // Además, guardar por chatId
      markReadByChatId();
    } catch {}
  }, [lastReadKey, normRoom, currentRole, markReadByChatId]);

  React.useEffect(() => setCurrentRole(role), [role]);

  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  React.useEffect(() => {
    if (typeof window === "undefined") return;
    const mq = window.matchMedia("(max-width: 768px)");
    const onChange = () => setIsMobile(mq.matches);
    onChange();
    mq.addEventListener?.("change", onChange);
    return () => mq.removeEventListener?.("change", onChange);
  }, []);

  React.useEffect(() => {
    // Al montar, si la vista está visible, marcar como leído
    if (
      typeof document !== "undefined" &&
      document.visibilityState === "visible"
    ) {
      markRead();
    }
    function onVis() {
      if (document.visibilityState === "visible") markRead();
    }
    function onFocus() {
      markRead();
    }
    if (typeof window !== "undefined") {
      document.addEventListener("visibilitychange", onVis);
      window.addEventListener("focus", onFocus);
    }
    return () => {
      if (typeof window !== "undefined") {
        document.removeEventListener("visibilitychange", onVis);
        window.removeEventListener("focus", onFocus);
      }
    };
  }, [markRead]);

  React.useEffect(() => {
    if (transport !== "ws") return;
    if (!normRoom) return;
    const proto =
      typeof window !== "undefined" && window.location.protocol === "https:"
        ? "wss"
        : "ws";
    const url = `${proto}://${
      window.location.host
    }/api/socket?room=${encodeURIComponent(normRoom)}`;
    const ws = new WebSocket(url);
    wsRef.current = ws;
    let alive = true;

    ws.onopen = () => {
      setConnected(true);
      try {
        while (pendingRef.current.length > 0 && ws.readyState === WS_OPEN) {
          const p = pendingRef.current.shift()!;
          ws.send(JSON.stringify(p));
        }
      } catch {}
    };
    ws.onclose = () => setConnected(false);
    ws.onerror = () => setConnected(false);
    ws.onmessage = (ev) => {
      try {
        const payload = JSON.parse(String(ev.data));
        if (payload?.type === "history" && Array.isArray(payload.data)) {
          if (!alive) return;
          setItems(payload.data as Message[]);
          for (const m of payload.data as Message[]) seenRef.current.add(m.id);
        } else if (payload?.type === "message" && payload.data) {
          const msg = payload.data as Message;
          if (!alive) return;
          if (!seenRef.current.has(msg.id)) {
            seenRef.current.add(msg.id);
            setItems((prev) => [...prev, msg]);
            const mine =
              (msg.sender || "").toLowerCase() ===
              (currentRole || "").toLowerCase();
            const isFocused =
              typeof document !== "undefined" ? document.hasFocus() : false;
            if (!mine && !isFocused) {
              console.debug(`Nuevo mensaje de ${msg.sender}:`, msg.text);
            }
            // si estamos viendo este chat y la ventana está enfocada, marcar como leído
            if (
              typeof document !== "undefined" &&
              document.visibilityState === "visible"
            ) {
              markRead();
            }
          }
        }
      } catch {}
    };

    return () => {
      alive = false;
      try {
        ws.close();
      } catch {}
      wsRef.current = null;
    };
  }, [transport, normRoom, currentRole, markRead]);

  // Transporte Socket.IO (servidor externo que habla con eventos chat.*)
  React.useEffect(() => {
    if (transport !== "socketio") return;
    let alive = true;
    (async () => {
      // Reinicia banderas por si cambiaron props (evita multi-create/join)
      createdRef.current = false;
      joinedRef.current = false;
      try {
        const url = socketio?.url || undefined;
        // 1) Obtener token de autenticación de la app (JWT) con espera breve si aún no está listo
        const resolveToken = async (): Promise<string | undefined> => {
          const override = (socketio as any)?.token as string | undefined;
          if (override && typeof override === "string") return override;
          // Espera hasta 4s en intervalos de 300ms si todavía no hay token (p. ej., hidratación auth)
          const deadline = Date.now() + 4000;
          while (alive && Date.now() < deadline) {
            const t = getAuthToken();
            if (t) return t;
            await new Promise((r) => setTimeout(r, 300));
          }
          return getAuthToken() || undefined;
        };
        const token = await resolveToken();
        try {
          const defaultOrigin =
            typeof window !== "undefined" && window.location?.origin
              ? window.location.origin
              : "<current-origin>";
          const base = url || defaultOrigin;
          const endpoint = `${base.replace(/\/$/, "")}/socket.io`;
          console.log("[ChatRealtime] socket url (base):", url ?? "<default>");
          console.log("[ChatRealtime] connect endpoint:", endpoint);
          console.log(
            "[ChatRealtime] token override (prop):",
            (socketio as any)?.token ?? null
          );
          console.log("[ChatRealtime] auth token used:", token);
        } catch {}
        if (!token) {
          // No conectar sin token; volveremos a intentar en el próximo render/cambio de props
          setConnected(false);
          return;
        }
        // 2) Conectarse via socket.io
        const { io } = await import("socket.io-client");
        // Autenticación: solo via auth.token (sin query) según políticas del servidor
        const sio = url
          ? io(url, {
              auth: { token },
              transports: ["websocket", "polling"],
              timeout: 20000,
            })
          : io({
              auth: { token },
              transports: ["websocket", "polling"],
              timeout: 20000,
            });
        sioRef.current = sio;
        sio.on("connect", () => {
          if (!alive) return;
          setConnected(true);
          // Al reconectar, permitir una sola emisión si listOnConnect=true
          listOnceRef.current = false;
        });
        sio.on("disconnect", () => {
          if (!alive) return;
          setConnected(false);
        });
        sio.on("connect_error", (err: any) => {
          try {
            console.error("[ChatRealtime] connect_error", err?.message || err);
          } catch {}
        });
        sio.on("error", (err: any) => {
          try {
            console.error("[ChatRealtime] error", err?.message || err);
          } catch {}
        });
        // 3) Escuchar mensajes entrantes
        sio.on("chat.message", (msg: any) => {
          if (!alive) return;
          try {
            try {
              console.debug("[chat.message] <=", {
                id_chat: msg?.id_chat,
                id_mensaje: msg?.id_mensaje,
                id_chat_participante_emisor: msg?.id_chat_participante_emisor,
              });
            } catch {}
            // Si el mensaje pertenece a OTRO chat (o aún no hay chat unido), avisar a la bandeja y salir
            if (
              msg?.id_chat != null &&
              String(msg.id_chat) !== String(chatId ?? "")
            ) {
              try {
                // Refrescar bandejas para traer último mensaje/orden
                window.dispatchEvent(
                  new CustomEvent("chat:list-refresh", {
                    detail: {
                      reason: "message-other-chat",
                      id_chat: msg?.id_chat,
                    },
                  })
                );
                // Evitar eco propio (por participante o por client_session)
                const isMineById =
                  (myParticipantId != null &&
                    String(msg?.id_chat_participante_emisor ?? "") ===
                      String(myParticipantId)) ||
                  (lastSentParticipantIdRef.current != null &&
                    String(msg?.id_chat_participante_emisor ?? "") ===
                      String(lastSentParticipantIdRef.current));
                const isMineBySession =
                  !!msg?.client_session &&
                  String(msg.client_session) ===
                    String(clientSessionRef.current);
                if (!isMineById && !isMineBySession) {
                  window.dispatchEvent(
                    new CustomEvent("chat:unread-bump", {
                      detail: {
                        chatId: msg?.id_chat,
                        role: currentRole,
                        at: Date.now(),
                      },
                    })
                  );
                  // Persistir incremento de no leídos por chatId
                  try {
                    const unreadKey = `chatUnreadById:${currentRole}:${String(
                      msg?.id_chat
                    )}`;
                    const prev = parseInt(
                      localStorage.getItem(unreadKey) || "0",
                      10
                    );
                    const next = (isNaN(prev) ? 0 : prev) + 1;
                    localStorage.setItem(unreadKey, String(next));
                    window.dispatchEvent(
                      new CustomEvent("chat:unread-count-updated", {
                        detail: {
                          chatId: msg?.id_chat,
                          role: currentRole,
                          count: next,
                        },
                      })
                    );
                  } catch {}
                }
              } catch {}
              return;
            }
            const id = String(
              msg?.id_mensaje ?? `${Date.now()}-${Math.random()}`
            );
            if (seenRef.current.has(id)) return;
            seenRef.current.add(id);
            const senderIsMeById =
              (myParticipantId != null &&
                String(msg?.id_chat_participante_emisor ?? "") ===
                  String(myParticipantId)) ||
              (lastSentParticipantIdRef.current != null &&
                String(msg?.id_chat_participante_emisor ?? "") ===
                  String(lastSentParticipantIdRef.current));
            const otherRoleByPanel: Sender = (() => {
              if (currentRole === "alumno") {
                return socketio?.idEquipo != null ? "coach" : "admin";
              }
              if (currentRole === "coach") return "alumno";
              return "alumno";
            })();
            const tipoNorm = normalizeTipo(
              msg?.participante_tipo ||
                getTipoByParticipantId(msg?.id_chat_participante_emisor)
            );
            const senderFromTipo: Sender | null = (() => {
              if (!tipoNorm) return null;
              if (tipoNorm === "cliente") return "alumno";
              if (tipoNorm === "equipo") return "coach";
              return "admin";
            })();
            const senderIsMineByTipo = (() => {
              if (!tipoNorm) return false;
              if (currentRole === "alumno") {
                return (
                  tipoNorm === "cliente" &&
                  socketio?.idCliente != null &&
                  String(msg?.id_cliente ?? "") === String(socketio?.idCliente)
                );
              }
              if (currentRole === "coach") {
                return (
                  tipoNorm === "equipo" &&
                  socketio?.idEquipo != null &&
                  String(msg?.id_equipo ?? "") === String(socketio?.idEquipo)
                );
              }
              return false;
            })();
            const sender: Sender =
              senderIsMeById || senderIsMineByTipo
                ? currentRole
                : otherRoleByPanel;
            const newMsg: Message = {
              id,
              room: normRoom,
              sender,
              text: String(msg?.contenido ?? ""),
              at: String(msg?.fecha_envio || new Date().toISOString()),
              delivered: true,
              read: false,
              srcParticipantId: msg?.id_chat_participante_emisor,
            };
            const mappedAtts = mapArchivoToAttachments(msg);
            if (mappedAtts) (newMsg as any).attachments = mappedAtts;
            setItems((prev) => {
              // Intentar reconciliar con mensaje optimista (mío) para evitar duplicados
              if (sender === currentRole) {
                const next = [...prev];
                for (let i = next.length - 1; i >= 0; i--) {
                  const mm = next[i];
                  if (
                    mm.sender === currentRole &&
                    mm.text === newMsg.text &&
                    mm.delivered === false
                  ) {
                    next[i] = { ...newMsg, read: mm.read || false };
                    return next;
                  }
                }
              }
              return [...prev, newMsg];
            });
            // Solicitar refresco de listado también cuando llega mensaje del chat actual
            try {
              window.dispatchEvent(
                new CustomEvent("chat:list-refresh", {
                  detail: { reason: "message-current-chat", id_chat: chatId },
                })
              );
            } catch {}
            if (
              typeof document !== "undefined" &&
              document.visibilityState === "visible"
            )
              markRead();
            // Si aún no conocemos myParticipantId pero este mensaje es "mío", tomar su id_participante
            if (
              (myParticipantId == null || myParticipantId === "") &&
              sender === currentRole &&
              msg?.id_chat_participante_emisor != null
            ) {
              try {
                console.debug(
                  "[chat.message] derivado myParticipantId desde message <=",
                  msg?.id_chat_participante_emisor
                );
              } catch {}
              setMyParticipantId(msg.id_chat_participante_emisor);
            }
          } catch {}
        });
        // Recibimos notificaciones de lectura
        sio.on("chat.message.read", (data: any) => {
          try {
            const idMsg = data?.id_mensaje ?? data?.id ?? null;
            if (!idMsg) return;
            setItems((prev) =>
              prev.map((m) =>
                String(m.id) === String(idMsg) ? { ...m, read: true } : m
              )
            );
          } catch {}
        });
        sio.on("chat.read.all", (_: any) => {
          try {
            // Marcar todos mis mensajes como leídos
            setItems((prev) =>
              prev.map((m) =>
                (m.sender || "").toLowerCase() ===
                (currentRole || "").toLowerCase()
                  ? { ...m, read: true }
                  : m
              )
            );
          } catch {}
        });
        // Typing indicator (on/off)
        sio.on("chat.typing", (data: any) => {
          try {
            if (!showTypingIndicator) return;
            const idChat = data?.id_chat ?? data?.chatId ?? null;
            if (
              idChat != null &&
              chatId != null &&
              String(idChat) !== String(chatId)
            ) {
              return; // evento de otro chat
            }
            // Si el backend reenvía a todos sin emisor, usa client_session para ignorar el propio
            if (
              data?.client_session &&
              String(data.client_session) === String(clientSessionRef.current)
            ) {
              return;
            }
            // Si no viene el emisor y tampoco viene una client_session, ignora para evitar eco local
            const emitterPid =
              data?.id_chat_participante_emisor ?? data?.emisor ?? null;
            if (
              (emitterPid == null || emitterPid === "") &&
              (!data?.client_session || data?.client_session === "")
            ) {
              return;
            }
            const isOn = data?.typing === true || data?.on === true;
            const isOff = data?.typing === false || data?.on === false;
            if (isOff) {
              setOtherTyping(false);
              return;
            }
            if (!isOn) return;
            // Ignorar si el emisor soy yo (cuando el backend re-emite a todos)
            if (
              emitterPid != null &&
              (myParticipantId != null ||
                lastSentParticipantIdRef.current != null)
            ) {
              const mineById =
                myParticipantId != null &&
                String(emitterPid) === String(myParticipantId);
              const mineByLast =
                lastSentParticipantIdRef.current != null &&
                String(emitterPid) === String(lastSentParticipantIdRef.current);
              if (mineById || mineByLast) {
                try {
                  console.debug("[chat.typing] ignored self", {
                    emitterPid,
                    clientSession: data?.client_session,
                  });
                } catch {}
                return;
              }
            }
            if (!otherTyping) {
              try {
                console.debug("[chat.typing] <= show typing", {
                  idChat,
                  emitterPid: data?.id_chat_participante_emisor,
                  clientSession: data?.client_session,
                });
              } catch {}
            }
            setOtherTyping(true);
            if (otherTypingTimerRef.current)
              clearTimeout(otherTypingTimerRef.current);
            otherTypingTimerRef.current = setTimeout(
              () => setOtherTyping(false),
              1800
            );
          } catch {}
        });

        // 4) Crear o unirse al chat automáticamente si se pide
        const wantCreate = socketio?.autoCreate ?? true;
        const wantJoin = socketio?.autoJoin ?? true;
        const initialChatId = socketio?.chatId ?? null;

        // Si cambió el chat solicitado, limpiamos UI y preparamos skeleton
        if (
          String(prevRequestedChatIdRef.current ?? "") !==
          String(initialChatId ?? "")
        ) {
          prevRequestedChatIdRef.current = initialChatId;
          setIsJoining(true);
          setItems([]);
          seenRef.current = new Set();
          setChatId(null);
          setOtherTyping(false);
        }

        // Delegar SIEMPRE a la versión conservadora para no confundir "mi" participante
        function assignMyParticipantId(participants: any[] | undefined | null) {
          assignMyParticipantIdFromList(participants);
        }

        if (
          wantCreate &&
          !initialChatId &&
          Array.isArray(socketio?.participants) &&
          !createdRef.current
        ) {
          // Find-or-create: antes de crear, buscar si ya existe un chat compatible con los participantes deseados
          createdRef.current = true; // evita dobles intentos si el effect re-ejecuta
          try {
            const desiredSet = buildKeySetFromArray(socketio!.participants);
            try {
              console.debug("[find-or-create] participantes deseados =>", {
                desired: Array.from(desiredSet.values()),
                raw: socketio!.participants,
              });
            } catch {}
            const listPayload: any = {};
            if (socketio?.idCliente != null) {
              listPayload.participante_tipo = "cliente";
              listPayload.id_cliente = String(socketio.idCliente);
            } else if (socketio?.idEquipo != null) {
              // Si solo tenemos equipo, listamos por equipo
              listPayload.participante_tipo = "equipo";
              listPayload.id_equipo = String(socketio.idEquipo);
            }
            // Si tenemos ambos (cliente y equipo), añadimos ambos filtros para acotar mejor
            if (socketio?.idEquipo != null) {
              listPayload.id_equipo = String(socketio.idEquipo);
            }
            const tryList = new Promise<any[]>((resolve) => {
              try {
                if (!listPayload.participante_tipo) return resolve([]);
                sio.emit("chat.list", listPayload, (ack: any) => {
                  const list: any[] = Array.isArray(ack?.data) ? ack.data : [];
                  resolve(list);
                });
              } catch {
                resolve([]);
              }
            });
            const list = await tryList;
            let matched: any | null = null;
            let subsetMatched: any | null = null;
            try {
              console.debug("[find-or-create] chats listados =>", list);
            } catch {}
            // Intentar macheo por participantes si vienen en el payload del listado
            for (const it of list) {
              const parts = it?.participants || it?.participantes || [];
              const remoteSet = buildKeySetFromArray(parts);
              const hasParts = remoteSet.size > 0;
              if (hasParts) {
                const eq = equalKeySets(desiredSet, remoteSet);
                const sub = isSubsetSet(desiredSet, remoteSet);
                try {
                  console.debug("[find-or-create] comparar", {
                    id_chat: it?.id_chat ?? it?.id,
                    remote: Array.from(remoteSet.values()),
                    equal: eq,
                    subset: sub,
                  });
                } catch {}
                if (eq) {
                  matched = it;
                  break;
                }
                if (!subsetMatched && sub) subsetMatched = it;
              }
            }
            if (!matched && subsetMatched) matched = subsetMatched;
            // Si no hay info de participantes en el listado, pero existen chats, tomar el más reciente
            // Importante: si el listado no trae participantes fiables, NO reutilizamos por "más reciente".
            // Creamos un chat nuevo al enviar para evitar reabrir conversaciones incorrectas.
            if (matched && matched.id_chat) {
              // Existe: hacemos join en lugar de crear
              const joinPayload = { id_chat: matched.id_chat };
              joinedRef.current = true;
              const matchedParts =
                matched?.participants || matched?.participantes || [];
              sio.emit("chat.join", joinPayload, (ack: any) => {
                try {
                  if (ack && ack.success) {
                    const data = ack.data || {};
                    const cid = data.id_chat ?? matched.id_chat;
                    if (cid != null) setChatId(cid);
                    if (data.my_participante)
                      setMyParticipantId(data.my_participante);
                    assignMyParticipantId(
                      data.participants || data.participantes || matchedParts
                    );
                    const msgsSrc = Array.isArray(data.messages)
                      ? data.messages
                      : Array.isArray((data as any).mensajes)
                      ? (data as any).mensajes
                      : [];
                    const msgs: any[] = msgsSrc;
                    try {
                      console.debug(
                        "[find-or-create] reutilizado chat existente",
                        {
                          id_chat: cid,
                          motivo: equalKeySets(
                            desiredSet,
                            buildKeySetFromArray(matchedParts)
                          )
                            ? "equal"
                            : "subset",
                          total_mensajes: msgs.length,
                        }
                      );
                    } catch {}
                    // Ocultar skeleton
                    setIsJoining(false);
                  } else {
                    // Si el join falla, caer a creación
                    doCreate();
                  }
                } catch {
                  doCreate();
                }
              });
            } else {
              // No existe: crear
              doCreate();
            }
          } catch {
            // Cualquier error: crear
            doCreate();
          }
          // helper local para crear
          function doCreate() {
            const payload: any = { participants: socketio!.participants };
            try {
              console.debug(
                "[find-or-create] creando chat con participantes =>",
                payload.participants
              );
            } catch {}
            sio.emit("chat.create-with-participants", payload, (ack: any) => {
              try {
                if (ack && ack.success && ack.data) {
                  const data = ack.data;
                  const cid = data.id_chat ?? data.id ?? null;
                  if (cid != null) setChatId(cid);
                  const parts = data.participants || data.participantes;
                  assignMyParticipantId(parts);
                  // Propagar a consumidores para que actualicen encabezados
                  try {
                    onChatInfo?.({
                      chatId: cid,
                      myParticipantId: myParticipantId,
                      participants: Array.isArray(parts) ? parts : null,
                    });
                  } catch {}
                  setIsJoining(false);
                } else if (ack && !ack.success) {
                  console.debug("Error create chat:", ack.error);
                  setIsJoining(false);
                }
              } catch {}
            });
          }
        }
      } catch (e) {
        console.debug("Socket.IO: no conectado:", e);
        setConnected(false);
      }
    })();
    return () => {
      alive = false;
      try {
        sioRef.current?.disconnect();
      } catch {}
      sioRef.current = null;
    };
  }, [
    transport,
    normRoom,
    currentRole,
    socketio?.url,
    socketio?.token,
    socketio?.autoCreate,
    socketio?.autoJoin,
    socketio?.idCliente,
    // Importante: NO dependemos de markRead ni de socketio?.participants para evitar reconexiones por cambios de estado (chatId/read).
    listOnConnect,
    showTypingIndicator,
  ]);

  // Listar conversaciones al conectar o bajo demanda
  React.useEffect(() => {
    if (transport !== "socketio") return;
    if (!connected) return;
    const sio = sioRef.current;
    if (!sio) return;
    // Si se solicita listado en la conexión o el padre cambia la señal
    if (listOnConnect) {
      if (listOnceRef.current) return; // sólo una vez por conexión
      listOnceRef.current = true;
    } else {
      if (requestListSignal == null) return;
    }
    try {
      const base = (listParamsRef.current || {}) as any;
      // Backend requiere participante_tipo + id_*; si llega "participants" desde el padre,
      // agregamos también el filtro válido por rol propio para evitar errores.
      const roleFilter: any = {};
      if (currentRole === "alumno") {
        let idCli = socketio?.idCliente;
        // Quitar heurística basada en tokenId; ahora el idCliente debe venir explícito
        if (idCli != null) {
          roleFilter.participante_tipo = "cliente";
          roleFilter.id_cliente = String(idCli);
        }
      } else if (currentRole === "coach") {
        if (socketio?.idEquipo != null) {
          roleFilter.participante_tipo = "equipo";
          roleFilter.id_equipo = String(socketio.idEquipo);
        }
      }
      let payload: any = {
        // Siempre incluir el filtro por rol para cumplir con los requisitos del backend
        ...roleFilter,
        ...base,
        // pedir explícitamente los participantes cuando el backend lo soporte
        include_participants: true,
        with_participants: true,
        includeParticipants: true,
        withParticipants: true,
      } as any;
      // En modo alumno, sólo forzar cliente si el padre NO pidió listar por equipo explícitamente
      if (currentRole === "alumno") {
        const baseAskedEquipo =
          String(base?.participante_tipo || "").toLowerCase() === "equipo" ||
          base?.id_equipo != null;
        if (!baseAskedEquipo && payload) {
          payload.participante_tipo = "cliente";
          if (roleFilter?.id_cliente != null && payload.id_cliente == null) {
            payload.id_cliente = String(roleFilter.id_cliente);
          }
          if ("id_equipo" in payload) delete payload.id_equipo;
        }
      }
      console.log("[chat.list] payload =>", payload);
      sio.emit("chat.list", payload, (ack: any) => {
        try {
          console.log("[chat.list] ack <=", ack);
          if (ack && ack.success === false) {
            console.log("[chat.list] error:", ack.error);
            // No sobrescribir la lista previa del padre en caso de error
            return;
          }
          const list = ack?.data ?? [];
          const baseList: any[] = Array.isArray(list) ? list : [];
          // Enriquecer: si el backend no envía participantes, probamos un join ligero para obtenerlos (máx 10)
          const needEnrich = baseList.some(
            (it) => !Array.isArray(it?.participants || it?.participantes)
          );
          if (needEnrich) {
            const now = Date.now();
            if (now - (lastEnrichAtRef.current || 0) < 20000) {
              // Evitar enriquecer demasiadas veces seguidas (join probes)
              // Entregar base una sola vez
              onChatsList?.(baseList);
              return;
            }
            lastEnrichAtRef.current = now;
            (async () => {
              try {
                const sorted = [...baseList]
                  .sort((a, b) => getItemTimestamp(b) - getItemTimestamp(a))
                  .slice(0, 10);
                const enriched: any[] = [];
                for (const it of sorted) {
                  const id = it?.id_chat ?? it?.id;
                  if (id == null) {
                    enriched.push(it);
                    continue;
                  }
                  const data = await probeJoin(id);
                  if (data && (data.participants || data.participantes)) {
                    enriched.push({
                      ...it,
                      participants: data.participants || data.participantes,
                    });
                  } else {
                    enriched.push(it);
                  }
                }
                // Mezclar enriquecidos con el resto (manteniendo orden original lo más posible)
                const byId = new Map<string, any>();
                for (const e of enriched) {
                  const id = String(e?.id_chat ?? e?.id ?? "");
                  if (id) byId.set(id, e);
                }
                const merged = baseList.map((it) => {
                  const id = String(it?.id_chat ?? it?.id ?? "");
                  return (id && byId.get(id)) || it;
                });
                onChatsList?.(merged);
              } catch {}
            })();
          } else {
            onChatsList?.(baseList);
          }
          // Si el padre pasó participants (yo↔target) y no tenemos chatId, intentar localizar conversación existente
          const desiredParts = participantsRef.current;
          const autoJoin = socketio?.autoJoin ?? true;
          const autoCreate = socketio?.autoCreate ?? true;
          if (
            Array.isArray(desiredParts) &&
            desiredParts.length >= 2 &&
            (chatId == null || chatId === "") &&
            autoJoin === false &&
            autoCreate === false
          ) {
            findExistingByParticipants(
              Array.isArray(list) ? list : [],
              desiredParts
            ).catch(() => {});
          }
        } catch {}
      });
    } catch {}
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [connected, requestListSignal, listOnConnect]);

  // Forzar refresco de listado (mis chats) para que el padre se actualice tras crear/join
  const refreshChatsList = React.useCallback(() => {
    try {
      if (transport !== "socketio") return;
      if (!connected) return;
      const now = Date.now();
      if (now - (lastListRefreshAtRef.current || 0) < 5000) return;
      lastListRefreshAtRef.current = now;
      const sio = sioRef.current;
      if (!sio) return;
      const base = (listParamsRef.current || {}) as any;
      const roleFilter: any = {};
      if (currentRole === "alumno") {
        let idCli = socketio?.idCliente;
        // Quitar heurística basada en tokenId; ahora el idCliente debe venir explícito
        if (idCli != null) {
          roleFilter.participante_tipo = "cliente";
          roleFilter.id_cliente = String(idCli);
        }
      } else if (currentRole === "coach") {
        let idEq = socketio?.idEquipo;
        if (idEq != null) {
          roleFilter.participante_tipo = "equipo";
          roleFilter.id_equipo = String(idEq);
        }
      }
      let payload: any = {
        // Siempre incluir el filtro por rol para cumplir con los requisitos del backend
        ...roleFilter,
        ...base,
        include_participants: true,
        with_participants: true,
        includeParticipants: true,
        withParticipants: true,
      } as any;
      if (currentRole === "alumno") {
        const baseAskedEquipo =
          String(base?.participante_tipo || "").toLowerCase() === "equipo" ||
          base?.id_equipo != null;
        if (!baseAskedEquipo && payload) {
          payload.participante_tipo = "cliente";
          if (roleFilter?.id_cliente != null && payload.id_cliente == null) {
            payload.id_cliente = String(roleFilter.id_cliente);
          }
          if ("id_equipo" in payload) delete payload.id_equipo;
        }
      }
      console.log("[chat.list/refresh] payload =>", payload);
      sio.emit("chat.list", payload, (ack: any) => {
        try {
          console.log("[chat.list/refresh] ack <=", ack);
          if (ack && ack.success === false) {
            console.log("[chat.list/refresh] error:", ack.error);
            // Mantener la lista actual del padre
            return;
          }
          const list = ack?.data ?? [];
          onChatsList?.(Array.isArray(list) ? list : []);
        } catch {}
      });
    } catch {}
  }, [
    connected,
    transport,
    currentRole,
    socketio?.idCliente,
    socketio?.idEquipo,
  ]);

  // Búsqueda activa de conversación existente por participantes (sin crear)
  const isFindingExistingRef = React.useRef<boolean>(false);
  function getItemTimestamp(it: any): number {
    const fields = [
      it?.last_message_at,
      it?.fecha_ultimo_mensaje,
      it?.updated_at,
      it?.fecha_actualizacion,
      it?.created_at,
      it?.fecha_creacion,
    ];
    for (const f of fields) {
      const t = Date.parse(String(f || ""));
      if (!isNaN(t)) return t;
    }
    const idNum = Number(it?.id_chat ?? it?.id ?? 0);
    return isNaN(idNum) ? 0 : idNum;
  }
  async function probeJoin(id: any): Promise<any | null> {
    return await new Promise((resolve) => {
      try {
        const sio = sioRef.current;
        if (!sio) return resolve(null);
        sio.emit("chat.join", { id_chat: id }, (ack: any) => {
          if (ack && ack.success) resolve(ack.data || {});
          else resolve(null);
        });
      } catch {
        resolve(null);
      }
    });
  }
  async function findExistingByParticipants(list: any[], desired: any[]) {
    if (isFindingExistingRef.current) return;
    isFindingExistingRef.current = true;
    try {
      // Si durante la detección ya hay chatId o se habilitó autoJoin, abortar
      if (latestChatIdRef.current != null || latestAutoJoinRef.current) return;
      const desiredSet = buildKeySetFromArray(desired);
      // 1) Intento directo si el listado ya trae participantes
      let candidate: any | null = null;
      const withParts = list.filter((it) =>
        Array.isArray(it?.participants || it?.participantes)
      );
      for (const it of withParts) {
        const parts = it?.participants || it?.participantes || [];
        const remoteSet = buildKeySetFromArray(parts);
        if (remoteSet.size === 0) continue;
        if (
          equalKeySets(desiredSet, remoteSet) ||
          isSubsetSet(desiredSet, remoteSet)
        ) {
          candidate = it;
          break;
        }
      }
      // 2) Si no hay participantes en el listado, probar unirse a los más recientes (límite 8)
      if (!candidate) {
        const sorted = [...list]
          .sort((a, b) => getItemTimestamp(b) - getItemTimestamp(a))
          .slice(0, 8);
        for (const it of sorted) {
          const id = it?.id_chat ?? it?.id;
          if (id == null) continue;
          const data = await probeJoin(id);
          // Revalidar condiciones tras await
          if (latestChatIdRef.current != null || latestAutoJoinRef.current)
            return;
          if (!data) continue;
          const parts = data.participants || data.participantes || [];
          const remoteSet = buildKeySetFromArray(parts);
          if (remoteSet.size === 0) continue;
          if (
            equalKeySets(desiredSet, remoteSet) ||
            isSubsetSet(desiredSet, remoteSet)
          ) {
            candidate = { ...it, participants: parts };
            // Conservar data del join para establecer estado sin segunda llamada
            const cid = data.id_chat ?? id;
            // Última validación antes de setear estado
            if (latestChatIdRef.current != null || latestAutoJoinRef.current)
              return;
            if (cid != null) setChatId(cid);
            if (data.my_participante) setMyParticipantId(data.my_participante);
            assignMyParticipantIdFromList(parts);
            const msgsSrc = Array.isArray(data.messages)
              ? data.messages
              : Array.isArray((data as any).mensajes)
              ? (data as any).mensajes
              : [];
            const otherRoleOnJoin: Sender = (() => {
              if (currentRole === "alumno") {
                return socketio?.idEquipo != null ? "coach" : "admin";
              }
              if (currentRole === "coach") return "alumno";
              return "alumno";
            })();
            const mapped: Message[] = msgsSrc.map((m: any) => {
              const isMineById =
                myParticipantId != null &&
                String(m?.id_chat_participante_emisor ?? "") ===
                  String(myParticipantId);
              const tipoNorm = normalizeTipo(
                m?.participante_tipo ||
                  getTipoByParticipantId(m?.id_chat_participante_emisor)
              );
              const isMineByTipo = (() => {
                if (!tipoNorm) return false;
                if (currentRole === "alumno") {
                  return (
                    tipoNorm === "cliente" &&
                    socketio?.idCliente != null &&
                    String(m?.id_cliente ?? "") === String(socketio?.idCliente)
                  );
                }
                if (currentRole === "coach") {
                  return (
                    tipoNorm === "equipo" &&
                    socketio?.idEquipo != null &&
                    String(m?.id_equipo ?? "") === String(socketio?.idEquipo)
                  );
                }
                return false;
              })();
              const senderFromTipo: Sender | null = (() => {
                if (tipoNorm === "cliente") return "alumno";
                if (tipoNorm === "equipo") return "coach";
                return null;
              })();
              const sender: Sender = isMineById
                ? currentRole
                : isMineByTipo
                ? currentRole
                : senderFromTipo || otherRoleOnJoin;
              return {
                id: String(m?.id_mensaje ?? `${Date.now()}-${Math.random()}`),
                room: normRoom,
                sender,
                text: String(m?.Contenido ?? m?.contenido ?? ""),
                at: String(m?.fecha_envio || new Date().toISOString()),
                delivered: true,
                read: !!m?.leido,
                srcParticipantId: m?.id_chat_participante_emisor,
                attachments: mapArchivoToAttachments(m),
              };
            });
            setItems(mapped);
            for (const m of mapped) seenRef.current.add(m.id);
            setIsJoining(false);
            try {
              console.debug("[find-existing] join por detección <=", {
                id_chat: cid,
              });
            } catch {}
            return;
          }
        }
      }
      if (candidate && (candidate.id_chat || candidate.id)) {
        // Unirse formalmente si no lo hicimos en el probe
        const id = candidate.id_chat ?? candidate.id;
        try {
          if (latestChatIdRef.current != null || latestAutoJoinRef.current)
            return;
          const sio = sioRef.current;
          sio?.emit("chat.join", { id_chat: id }, (ack: any) => {
            try {
              if (latestChatIdRef.current != null || latestAutoJoinRef.current)
                return;
              if (ack && ack.success) {
                const data = ack.data || {};
                const cid = data.id_chat ?? id;
                if (cid != null) setChatId(cid);
                if (data.my_participante)
                  setMyParticipantId(data.my_participante);
                assignMyParticipantIdFromList(
                  data.participants || data.participantes || []
                );
                const msgsSrc = Array.isArray(data.messages)
                  ? data.messages
                  : Array.isArray((data as any).mensajes)
                  ? (data as any).mensajes
                  : [];
                const otherRoleOnJoin: Sender = (() => {
                  if (currentRole === "alumno") {
                    return socketio?.idEquipo != null ? "coach" : "admin";
                  }
                  if (currentRole === "coach") return "alumno";
                  return "alumno";
                })();
                const mapped: Message[] = msgsSrc.map((m: any) => {
                  const isMineById =
                    myParticipantId != null &&
                    String(m?.id_chat_participante_emisor ?? "") ===
                      String(myParticipantId);
                  const tipoNorm = normalizeTipo(
                    m?.participante_tipo ||
                      getTipoByParticipantId(m?.id_chat_participante_emisor)
                  );
                  const isMineByTipo = (() => {
                    if (!tipoNorm) return false;
                    if (currentRole === "alumno") {
                      return (
                        tipoNorm === "cliente" &&
                        socketio?.idCliente != null &&
                        String(m?.id_cliente ?? "") ===
                          String(socketio?.idCliente)
                      );
                    }
                    if (currentRole === "coach") {
                      return (
                        tipoNorm === "equipo" &&
                        socketio?.idEquipo != null &&
                        String(m?.id_equipo ?? "") ===
                          String(socketio?.idEquipo)
                      );
                    }
                    return false;
                  })();
                  const senderFromTipo: Sender | null = (() => {
                    if (tipoNorm === "cliente") return "alumno";
                    if (tipoNorm === "equipo") return "coach";
                    return null;
                  })();
                  const sender: Sender = isMineById
                    ? currentRole
                    : isMineByTipo
                    ? currentRole
                    : senderFromTipo || otherRoleOnJoin;
                  return {
                    id: String(
                      m?.id_mensaje ?? `${Date.now()}-${Math.random()}`
                    ),
                    room: normRoom,
                    sender,
                    text: String(m?.Contenido ?? m?.contenido ?? ""),
                    at: String(m?.fecha_envio || new Date().toISOString()),
                    delivered: true,
                    read: !!m?.leido,
                    srcParticipantId: m?.id_chat_participante_emisor,
                    attachments: mapArchivoToAttachments(m),
                  };
                });
                setItems(mapped);
                for (const m of mapped) seenRef.current.add(m.id);
                setIsJoining(false);
                console.debug("[find-existing] join directo <=", {
                  id_chat: cid,
                });
              }
            } catch {}
          });
        } catch {}
      }
    } finally {
      isFindingExistingRef.current = false;
    }
  }

  // Unirse a un chat existente cuando cambia socketio.chatId SIN reconectar el socket
  React.useEffect(() => {
    if (transport !== "socketio") return;
    const sio = sioRef.current;
    if (!sio) {
      // Si no hay socket disponible, no bloquear la UI con el skeleton
      setIsJoining(false);
      return;
    }
    const newId = socketio?.chatId ?? null;
    const autoJoin = socketio?.autoJoin ?? true;
    if (String(prevRequestedChatIdRef.current ?? "") === String(newId ?? ""))
      return;
    prevRequestedChatIdRef.current = newId;
    // Antes de limpiar UI, verificar si realmente haremos join
    if (newId == null || !autoJoin) {
      setIsJoining(false);
      return;
    }
    if (joinInFlightRef.current) {
      setIsJoining(false);
      return;
    }
    if (String(lastJoinedChatIdRef.current ?? "") === String(newId)) {
      // Ya estamos en este chat: no limpiar la UI ni unir de nuevo
      setIsJoining(false);
      return;
    }
    // Reset de UI minimal para el nuevo chat (ahora sí)
    setIsJoining(true);
    setItems([]);
    seenRef.current = new Set();
    setChatId(null);
    setOtherTyping(false);
    try {
      // Failsafe: si no recibimos ack en tiempo razonable, ocultar skeleton
      const t = setTimeout(() => {
        try {
          setIsJoining(false);
        } catch {}
      }, 6000);
      joinInFlightRef.current = true;
      sio.emit("chat.join", { id_chat: newId }, (ack: any) => {
        try {
          clearTimeout(t);
          joinInFlightRef.current = false;
          if (ack && ack.success) {
            const data = ack.data || {};
            const cid = data.id_chat ?? newId;
            if (cid != null) setChatId(cid);
            lastJoinedChatIdRef.current = cid;
            if (data.my_participante) setMyParticipantId(data.my_participante);
            const parts = data.participants || data.participantes;
            assignMyParticipantIdFromList(parts);
            // Mapear mensajes cargados
            const msgsSrc = Array.isArray(data.messages)
              ? data.messages
              : Array.isArray((data as any).mensajes)
              ? (data as any).mensajes
              : [];
            const otherRoleOnJoin: Sender = (() => {
              if (currentRole === "alumno") {
                return socketio?.idEquipo != null ? "coach" : "admin";
              }
              if (currentRole === "coach") return "alumno";
              return "alumno";
            })();
            const mapped: Message[] = msgsSrc.map((m: any) => {
              const isMineById =
                myParticipantId != null &&
                String(m?.id_chat_participante_emisor ?? "") ===
                  String(myParticipantId);
              const tipoNorm = normalizeTipo(
                m?.participante_tipo ||
                  getTipoByParticipantId(m?.id_chat_participante_emisor)
              );
              const isMineByTipo = (() => {
                if (!tipoNorm) return false;
                if (currentRole === "alumno") {
                  return (
                    tipoNorm === "cliente" &&
                    socketio?.idCliente != null &&
                    String(m?.id_cliente ?? "") === String(socketio?.idCliente)
                  );
                }
                if (currentRole === "coach") {
                  return (
                    tipoNorm === "equipo" &&
                    socketio?.idEquipo != null &&
                    String(m?.id_equipo ?? "") === String(socketio?.idEquipo)
                  );
                }
                return false;
              })();
              const senderFromTipo: Sender | null = (() => {
                if (tipoNorm === "cliente") return "alumno";
                if (tipoNorm === "equipo") return "coach";
                return null;
              })();
              const sender: Sender = isMineById
                ? currentRole
                : isMineByTipo
                ? currentRole
                : senderFromTipo || otherRoleOnJoin;
              return {
                id: String(m?.id_mensaje ?? `${Date.now()}-${Math.random()}`),
                room: normRoom,
                sender,
                text: String(m?.Contenido ?? m?.contenido ?? ""),
                at: String(m?.fecha_envio || new Date().toISOString()),
                delivered: true,
                read: !!m?.leido,
                srcParticipantId: m?.id_chat_participante_emisor,
                attachments: mapArchivoToAttachments(m),
              };
            });
            setItems(mapped);
            for (const m of mapped) seenRef.current.add(m.id);
            try {
              console.debug("[chat.join] (on chatId change) <=", {
                id_chat: cid,
                my_participante: data?.my_participante,
                total_mensajes: mapped.length,
              });
            } catch {}
            setIsJoining(false);
          } else {
            setIsJoining(false);
          }
        } catch {
          joinInFlightRef.current = false;
          setIsJoining(false);
        }
      });
    } catch {
      joinInFlightRef.current = false;
      setIsJoining(false);
    }
  }, [socketio?.chatId]);

  // Enviar "read all" automáticamente si la ventana está visible y hay chatId
  React.useEffect(() => {
    if (transport !== "socketio") return;
    if (!connected || chatId == null) return;
    if (typeof document === "undefined") return;
    if (document.visibilityState !== "visible") return;
    const now = Date.now();
    if (now - (lastReadEmitRef.current || 0) < 1200) return;
    const sio = sioRef.current;
    try {
      lastReadEmitRef.current = now;
      sio?.emit("chat.read.all", { id_chat: chatId });
      markRead();
    } catch {}
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [items.length, connected, chatId]);

  // SSE transport (server-sent events via /api/realtime)
  React.useEffect(() => {
    if (transport !== "sse") return;
    if (!normRoom) return;
    let alive = true;
    const url = `/api/realtime?room=${encodeURIComponent(normRoom)}`;
    try {
      const es = new EventSource(url);
      esRef.current = es;
      setConnected(true);
      es.onmessage = (ev) => {
        try {
          const msg = JSON.parse(String(ev.data || "{}"));
          // Esperamos objetos Message directos (sin wrapper type)
          if (!msg || !msg.id) return;
          if (!alive) return;
          if (!seenRef.current.has(msg.id)) {
            seenRef.current.add(msg.id);
            setItems((prev) => [...prev, msg]);
            if (
              typeof document !== "undefined" &&
              document.visibilityState === "visible"
            ) {
              markRead();
            }
          }
        } catch {}
      };
      es.onerror = () => {
        setConnected(false);
      };
    } catch {
      setConnected(false);
    }
    return () => {
      alive = false;
      try {
        esRef.current?.close();
      } catch {}
      esRef.current = null;
    };
  }, [transport, normRoom, markRead]);

  React.useEffect(() => {
    if (transport !== "local") return;
    if (!normRoom) return;

    try {
      const raw = localStorage.getItem(storageKey);
      if (raw) {
        const list = JSON.parse(raw) as Message[];
        setItems(list);
        for (const m of list) seenRef.current.add(m.id);
      } else {
        setItems([]);
      }
    } catch {
      setItems([]);
    }
    setConnected(true);

    let bc: BroadcastChannel | null = null;
    try {
      bc = new BroadcastChannel(`chat:${normRoom}`);
      bcRef.current = bc;
      bc.onmessage = (ev: MessageEvent) => {
        const data = ev.data;
        if (data?.type === "message" && data.msg) {
          const msg = data.msg as Message;
          if (seenRef.current.has(msg.id)) return;
          seenRef.current.add(msg.id);
          setItems((prev) => {
            const next = [...prev, msg];
            try {
              localStorage.setItem(storageKey, JSON.stringify(next));
            } catch {}
            return next;
          });
          const mine =
            (msg.sender || "").toLowerCase() ===
            (currentRole || "").toLowerCase();
          if (!mine)
            console.debug(`Nuevo mensaje BC de ${msg.sender}:`, msg.text);
        }
      };
    } catch {
      bcRef.current = null;
    }

    const onStorage = (e: StorageEvent) => {
      if (e.key !== storageKey || !e.newValue) return;
      try {
        const list = JSON.parse(e.newValue) as Message[];
        const news: Message[] = [];
        for (const m of list)
          if (!seenRef.current.has(m.id)) {
            seenRef.current.add(m.id);
            news.push(m);
          }
        if (news.length) setItems((prev) => [...prev, ...news]);
      } catch {}
    };
    window.addEventListener("storage", onStorage);

    return () => {
      window.removeEventListener("storage", onStorage);
      try {
        bc?.close();
      } catch {}
      bcRef.current = null;
    };
  }, [transport, normRoom, storageKey, currentRole]);

  React.useEffect(() => {
    if (typeof window === "undefined") return;
    // Auto-scroll solo si el usuario está cerca del fondo
    requestAnimationFrame(() => {
      try {
        if (pinnedToBottomRef.current) {
          bottomRef.current?.scrollIntoView({ behavior: "auto", block: "end" });
        }
      } catch {}
    });
  }, [items.length]);

  const onScrollContainer = React.useCallback(() => {
    const el = scrollRef.current;
    if (!el) return;
    const threshold = 100;
    const distance = el.scrollHeight - el.scrollTop - el.clientHeight;
    pinnedToBottomRef.current = distance <= threshold;
  }, []);
  // Intenta resolver mi id de participante consultando chat.list
  const resolveMyParticipantIdFromList = React.useCallback(async (): Promise<
    string | number | null
  > => {
    try {
      if (transport !== "socketio") return null;
      const sio = sioRef.current;
      if (!sio) return null;
      // Construir payload en función del rol actual. Esto evita elegir el participante equivocado
      // cuando, por ejemplo, en la vista del alumno sólo se proporcionó idEquipo.
      const payload: any = {};
      if (currentRole === "alumno") {
        payload.participante_tipo = "cliente";
        let idCli = socketio?.idCliente;
        // Quitar heurística basada en tokenId; ahora el idCliente debe venir explícito
        if (idCli != null) payload.id_cliente = String(idCli);
        if ("id_equipo" in payload) delete payload.id_equipo;
      } else if (currentRole === "coach") {
        payload.participante_tipo = "equipo";
        if (socketio?.idEquipo != null) {
          payload.id_equipo = String(socketio.idEquipo);
        }
      } else {
        // Sin un rol determinístico, no podemos resolver correctamente
        return null;
      }
      try {
        console.log("[chat.list/resolveMyParticipant] payload =>", payload);
      } catch {}
      return await new Promise((resolve) => {
        try {
          sio.emit("chat.list", payload, (ack: any) => {
            try {
              console.log("[chat.list/resolveMyParticipant] ack <=", ack);
              const list: any[] = Array.isArray(ack?.data) ? ack.data : [];
              const currentId = chatId != null ? String(chatId) : null;
              const item = currentId
                ? list.find(
                    (it) => String(it?.id_chat ?? it?.id ?? "") === currentId
                  )
                : list[0];
              if (!item) return resolve(null);
              if (item?.my_participante != null)
                return resolve(item.my_participante);
              const parts = item?.participants || item?.participantes || [];
              if (Array.isArray(parts) && parts.length) {
                if (payload.participante_tipo === "cliente") {
                  // Buscar mi participante cliente (por id o por unicidad)
                  let mine = null as any;
                  if (payload.id_cliente != null) {
                    mine = parts.find(
                      (p: any) =>
                        normalizeTipo(p?.participante_tipo) === "cliente" &&
                        String(p?.id_cliente) === String(payload.id_cliente)
                    );
                  }
                  if (!mine) {
                    const clientes = parts.filter(
                      (p: any) =>
                        normalizeTipo(p?.participante_tipo) === "cliente"
                    );
                    if (clientes.length === 1) mine = clientes[0];
                    else if (clientes.length > 1)
                      mine =
                        clientes.find((p: any) => !!p?.id_chat_participante) ??
                        clientes[0];
                  }
                  if (mine?.id_chat_participante != null)
                    return resolve(mine.id_chat_participante);
                } else if (payload.participante_tipo === "equipo") {
                  // Buscar mi participante equipo (por id o por unicidad)
                  let mine = null as any;
                  if (payload.id_equipo != null) {
                    mine = parts.find(
                      (p: any) =>
                        normalizeTipo(p?.participante_tipo) === "equipo" &&
                        String(p?.id_equipo) === String(payload.id_equipo)
                    );
                  }
                  if (!mine) {
                    const equipos = parts.filter(
                      (p: any) =>
                        normalizeTipo(p?.participante_tipo) === "equipo"
                    );
                    if (equipos.length === 1) mine = equipos[0];
                    else if (equipos.length > 1)
                      mine =
                        equipos.find((p: any) => !!p?.id_chat_participante) ??
                        equipos[0];
                  }
                  if (mine?.id_chat_participante != null)
                    return resolve(mine.id_chat_participante);
                }
              }
              resolve(null);
            } catch {
              resolve(null);
            }
          });
        } catch {
          resolve(null);
        }
      });
    } catch {
      return null;
    }
  }, [transport, socketio?.idCliente, socketio?.idEquipo, chatId, currentRole]);

  function autoSize() {
    const ta = inputRef.current;
    if (!ta) return;
    ta.style.height = "auto";
    ta.style.height = Math.min(200, ta.scrollHeight) + "px";
  }

  async function readFilesAsBase64(
    files: FileList | File[] | null
  ): Promise<Attachment[]> {
    if (!files || ("length" in files && files.length === 0)) return [];
    const arr = Array.isArray(files) ? files : Array.from(files);
    const enc = async (file: File): Promise<Attachment> => {
      const buf = await file.arrayBuffer();
      const bytes = new Uint8Array(buf);
      let binary = "";
      for (let i = 0; i < bytes.length; i++)
        binary += String.fromCharCode(bytes[i]);
      const b64 = btoa(binary);
      return {
        id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        name: file.name,
        mime: file.type || "application/octet-stream",
        size: file.size,
        data_base64: b64,
      };
    };
    const out: Attachment[] = [];
    for (const f of arr) out.push(await enc(f));
    return out;
  }

  const [pendingFiles, setPendingFiles] = React.useState<File[]>([]);
  const [pendingPreviews, setPendingPreviews] = React.useState<
    { url: string; name: string; type: string; size: number }[]
  >([]);

  React.useEffect(() => {
    const urls = pendingFiles.map((f) => ({
      url: URL.createObjectURL(f),
      name: f.name,
      type: f.type,
      size: f.size,
    }));
    setPendingPreviews(urls);
    return () => {
      urls.forEach((p) => URL.revokeObjectURL(p.url));
    };
  }, [pendingFiles]);

  function onFileInputChange(e: React.ChangeEvent<HTMLInputElement>) {
    const list = Array.from(e.target.files ?? []);
    if (!list.length) return;
    setPendingFiles((prev) => prev.concat(list).slice(0, 10));
    e.currentTarget.value = "";
  }

  async function generateTicketFromRecent() {
    try {
      const now = Date.now();
      const cutoff = now - 30 * 60 * 1000;
      const recent = items.filter((m) => {
        const t = Date.parse(m.at || "");
        return !isNaN(t) && t >= cutoff;
      });
      if (!recent || recent.length === 0) {
        console.debug("No hay mensajes en los últimos 30 minutos");
        return;
      }

      let suggested = "Ticket desde chat";
      const fromAlumno = [...recent]
        .reverse()
        .find((m) => m.sender === "alumno" && (m.text || "").trim());
      if (fromAlumno && fromAlumno.text) {
        suggested = String(fromAlumno.text).trim().slice(0, 120);
      } else {
        const joined = recent
          .map((m) => (m.text || "").trim())
          .filter(Boolean)
          .slice(-3)
          .join(" — ");
        if (joined) suggested = joined.slice(0, 120);
      }

      const atts: Attachment[] = [];
      for (const m of recent) {
        const aList = Array.isArray(m.attachments) ? m.attachments : [];
        for (const a of aList) {
          if (!a) continue;
          atts.push(a);
        }
      }

      setTicketTitle(suggested);
      setTicketDescription(
        recent.map((m) => `[${m.sender}]: ${m.text}`).join("\n\n")
      );
      setTicketType("");
      setTicketAutoGenerated(true);
      setTicketSelectedMessages(recent);
      setTicketAttachments(atts);
      setTicketModalOpen(true);

      console.debug("Generando propuesta de ticket para revisión");
    } catch (err) {
      console.error(err);
      console.debug("Error al generar propuesta");
    }
  }

  function removePendingAt(i: number) {
    setPendingFiles((prev) => prev.filter((_, idx) => idx !== i));
  }

  async function send() {
    const val = text.trim();
    if (!val && pendingFiles.length === 0) return;

    try {
      const attachments = await readFilesAsBase64(pendingFiles);

      const clientId = `${Date.now()}-${Math.random()
        .toString(36)
        .slice(2, 8)}`;
      const localMsg: Message = {
        id: clientId,
        room: normRoom,
        sender: currentRole,
        text: val,
        at: new Date().toISOString(),
        attachments,
      };

      setText("");
      if (inputRef.current) {
        inputRef.current.value = "";
        autoSize();
      }
      if (fileRef.current) fileRef.current.value = "";
      setPendingFiles([]);

      if (transport === "local") {
        setItems((prev) => {
          const next = [...prev, localMsg];
          try {
            localStorage.setItem(storageKey, JSON.stringify(next));
          } catch {}
          return next;
        });
        seenRef.current.add(clientId);
        try {
          bcRef.current?.postMessage({ type: "message", msg: localMsg });
        } catch {}
        markRead();
        return;
      }

      if (transport === "sse") {
        // enviar vía POST al endpoint SSE
        setItems((prev) => [...prev, localMsg]);
        seenRef.current.add(clientId);
        try {
          await fetch(`/api/realtime`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              room: normRoom,
              sender: currentRole,
              text: val,
            }),
          });
        } catch {}
        markRead();
        return;
      }

      // Socket.IO
      if (transport === "socketio") {
        const sio = sioRef.current;
        try {
          if (!sio) throw new Error("No socket");
          // Si no hay chatId aún, intenta encontrar o crear uno al vuelo
          if (chatId == null) {
            const ok = await ensureChatReadyForSend();
            if (!ok) {
              console.debug(
                "[chat.message.send] bloqueado: no se pudo preparar chat"
              );
              return; // Evitar continuar sin contexto y provocar loops de consultas
            }
          }
          // Resolver myParticipantId si falta (histórico -> lista)
          let effectiveMyParticipantId: any = myParticipantId;
          if (effectiveMyParticipantId == null) {
            const lastMine = [...items]
              .reverse()
              .find(
                (m) => m.sender === currentRole && m.srcParticipantId != null
              );
            if (lastMine && lastMine.srcParticipantId != null) {
              effectiveMyParticipantId = lastMine.srcParticipantId as any;
              setMyParticipantId(effectiveMyParticipantId);
            }
          }
          if (
            chatId != null &&
            (effectiveMyParticipantId == null ||
              effectiveMyParticipantId === "")
          ) {
            try {
              const pid = await resolveMyParticipantIdFromList();
              if (pid != null) {
                effectiveMyParticipantId = pid as any;
                setMyParticipantId(pid);
              }
            } catch {}
          }
          // Fallback adicional: intenta resolver a partir de participantes del último join
          if (
            chatId != null &&
            (effectiveMyParticipantId == null ||
              effectiveMyParticipantId === "")
          ) {
            try {
              const parts = Array.isArray(joinedParticipantsRef.current)
                ? joinedParticipantsRef.current
                : [];
              if (parts.length) {
                if (currentRole === "alumno") {
                  const mine1 = parts.find(
                    (p: any) =>
                      normalizeTipo(p?.participante_tipo) === "cliente" &&
                      (socketio?.idCliente != null
                        ? String(p?.id_cliente) === String(socketio?.idCliente)
                        : true)
                  );
                  if (mine1?.id_chat_participante != null)
                    effectiveMyParticipantId = mine1.id_chat_participante;
                  if (effectiveMyParticipantId == null) {
                    const onlyCliente = parts.filter(
                      (p: any) =>
                        normalizeTipo(p?.participante_tipo) === "cliente"
                    );
                    if (
                      onlyCliente.length === 1 &&
                      onlyCliente[0]?.id_chat_participante != null
                    )
                      effectiveMyParticipantId =
                        onlyCliente[0].id_chat_participante;
                  }
                } else if (currentRole === "coach") {
                  const mine2 = parts.find(
                    (p: any) =>
                      normalizeTipo(p?.participante_tipo) === "equipo" &&
                      (socketio?.idEquipo != null
                        ? String(p?.id_equipo) === String(socketio?.idEquipo)
                        : true)
                  );
                  if (mine2?.id_chat_participante != null)
                    effectiveMyParticipantId = mine2.id_chat_participante;
                  if (effectiveMyParticipantId == null) {
                    const onlyEquipo = parts.filter(
                      (p: any) =>
                        normalizeTipo(p?.participante_tipo) === "equipo"
                    );
                    if (
                      onlyEquipo.length === 1 &&
                      onlyEquipo[0]?.id_chat_participante != null
                    )
                      effectiveMyParticipantId =
                        onlyEquipo[0].id_chat_participante;
                  }
                }
                if (effectiveMyParticipantId != null)
                  setMyParticipantId(effectiveMyParticipantId);
              }
            } catch {}
          }
          // Pequeña espera activa para permitir que ensureChatReadyForSend/joins asignen myParticipantId
          if (
            chatId != null &&
            (effectiveMyParticipantId == null ||
              effectiveMyParticipantId === "")
          ) {
            for (let i = 0; i < 5; i++) {
              await new Promise((r) => setTimeout(r, 120));
              if (myParticipantId != null && myParticipantId !== "") {
                effectiveMyParticipantId = myParticipantId as any;
                break;
              }
              // Try derive from joinedParticipantsRef
              try {
                const parts = Array.isArray(joinedParticipantsRef.current)
                  ? joinedParticipantsRef.current
                  : [];
                if (parts.length) {
                  if (currentRole === "alumno") {
                    const mine1 = parts.find(
                      (p: any) =>
                        normalizeTipo(p?.participante_tipo) === "cliente" &&
                        (socketio?.idCliente != null
                          ? String(p?.id_cliente) ===
                            String(socketio?.idCliente)
                          : true)
                    );
                    if (mine1?.id_chat_participante != null) {
                      effectiveMyParticipantId = mine1.id_chat_participante;
                      setMyParticipantId(effectiveMyParticipantId);
                      break;
                    }
                  } else if (currentRole === "coach") {
                    const mine2 = parts.find(
                      (p: any) =>
                        normalizeTipo(p?.participante_tipo) === "equipo" &&
                        (socketio?.idEquipo != null
                          ? String(p?.id_equipo) === String(socketio?.idEquipo)
                          : true)
                    );
                    if (mine2?.id_chat_participante != null) {
                      effectiveMyParticipantId = mine2.id_chat_participante;
                      setMyParticipantId(effectiveMyParticipantId);
                      break;
                    }
                  }
                }
              } catch {}
            }
          }
          if (chatId == null || effectiveMyParticipantId == null) {
            console.debug("[chat.message.send] bloqueado: falta contexto", {
              chatId,
              myParticipantId: effectiveMyParticipantId,
              role: currentRole,
              destino: currentRole === "alumno" ? "coach" : "alumno",
            });
            return;
          } else {
            const payload = {
              id_chat: chatId,
              id_chat_participante_emisor: effectiveMyParticipantId,
              contenido: val,
              client_session: clientSessionRef.current,
            };
            try {
              console.debug("[chat.message.send] =>", {
                id_chat: payload.id_chat,
                emisor: payload.id_chat_participante_emisor,
                role: currentRole,
                destino: currentRole === "alumno" ? "coach" : "alumno",
                texto: String(val).slice(0, 120),
              });
            } catch {}
            // Marca el último id de participante usado para enviar
            lastSentParticipantIdRef.current = effectiveMyParticipantId;
            // Optimista: mostrar el mensaje local y registrar para reconciliar
            setItems((prev) => [
              ...prev,
              {
                ...localMsg,
                delivered: false,
                read: false,
                srcParticipantId: effectiveMyParticipantId,
              },
            ]);
            seenRef.current.add(clientId);
            outboxRef.current.push({
              clientId,
              text: val,
              at: Date.now(),
              pid: effectiveMyParticipantId,
            });
            sio.emit("chat.message.send", payload, (ack: any) => {
              try {
                if (ack && !ack.success) {
                  console.debug("[chat.message.send] error:", ack.error);
                } else {
                  console.debug("[chat.message.send] ack <=", ack);
                  // Marcar optimista como entregado y reconciliar id si viene en el ack
                  setItems((prev) => {
                    const next = [...prev];
                    const idx = next.findIndex((m) => m.id === clientId);
                    if (idx >= 0) {
                      const serverId = ack?.data?.id_mensaje ?? ack?.data?.id;
                      next[idx] = {
                        ...next[idx],
                        id: serverId ? String(serverId) : next[idx].id,
                        delivered: true,
                      };
                      if (serverId) seenRef.current.add(String(serverId));
                    }
                    return next;
                  });
                }
              } catch {}
            });
          }
        } catch {}
        markRead();
        return;
      }

      // default ws
      {
        setItems((prev) => [...prev, localMsg]);
        seenRef.current.add(clientId);
        const ws = wsRef.current;
        const payload = {
          type: "message" as const,
          id: clientId,
          room: normRoom,
          sender: currentRole,
          text: val,
          attachments,
        };
        if (!ws || ws.readyState !== WS_OPEN) {
          pendingRef.current.push({ ...payload });
          if (!connected)
            console.debug("Conectando… Tu mensaje se enviará al reconectarse.");
          return;
        }
        ws.send(JSON.stringify(payload));
        markRead();
      }
    } catch {
      console.debug("No se pudo enviar el mensaje");
    }
  }

  function onPickFiles() {
    fileRef.current?.click();
  }

  // Emite eventos typing on/off para Socket.IO
  const typingTimerRef = React.useRef<any>(null);
  function emitTyping(on: boolean) {
    try {
      if (transport !== "socketio") return;
      const sio = sioRef.current;
      if (!sio) return;
      if (chatId == null) return;
      // incluir el id del emisor cuando lo tengamos para que el backend pueda excluir al emisor
      const emitter =
        myParticipantId != null
          ? myParticipantId
          : lastSentParticipantIdRef.current != null
          ? lastSentParticipantIdRef.current
          : undefined;
      const payload: any = { id_chat: chatId, typing: !!on };
      if (emitter != null) payload.id_chat_participante_emisor = emitter;
      payload.client_session = clientSessionRef.current;
      sio.emit("chat.typing", payload);
    } catch {}
  }

  // Garantiza que exista un chat listo para enviar. Busca existente o crea si no hay.
  async function ensureChatReadyForSend(): Promise<boolean> {
    try {
      if (transport !== "socketio") return false;
      if (chatId != null) return true;
      const sio = sioRef.current;
      if (!sio) return false;
      if (creatingRef.current) {
        // Espera activa simple a que termine otro hilo de creación
        for (let i = 0; i < 20; i++) {
          await new Promise((r) => setTimeout(r, 100));
          if (chatId != null) return true;
        }
        return chatId != null;
      }
      const participants = participantsRef.current ?? socketio?.participants;
      if (!Array.isArray(participants) || participants.length === 0) {
        console.log("[ensureChatReadyForSend] faltan participants para crear");
        return false;
      }
      creatingRef.current = true;
      setIsJoining(true);
      // Intentar encontrar existente
      const desiredSet = buildKeySetFromArray(participants);
      try {
        console.log("[ensureChatReadyForSend] participantes deseados =>", {
          desired: Array.from(desiredSet.values()),
          raw: participants,
          role: currentRole,
          idCliente: socketio?.idCliente,
          idEquipo: socketio?.idEquipo,
        });
      } catch {}
      // NOTA: el backend requiere participante_tipo + id_*, por lo que evitamos pedir chat.list por participants aquí.
      const listPayload: any = {};
      if (socketio?.idCliente != null) {
        listPayload.participante_tipo = "cliente";
        listPayload.id_cliente = String(socketio.idCliente);
      } else if (socketio?.idEquipo != null) {
        listPayload.participante_tipo = "equipo";
        listPayload.id_equipo = String(socketio.idEquipo);
      }
      // Si los participantes deseados incluyen un equipo, y estamos listando como cliente,
      // añade id_equipo para acotar mejor la búsqueda (si el backend lo soporta)
      try {
        const desiredPartsTmp = Array.isArray(participants)
          ? participants
          : Array.isArray(participantsRef.current)
          ? participantsRef.current
          : [];
        const equipoPart = desiredPartsTmp.find(
          (p: any) =>
            String((p?.participante_tipo || "").toLowerCase()) === "equipo" &&
            p?.id_equipo != null
        );
        if (
          equipoPart &&
          listPayload.participante_tipo === "cliente" &&
          listPayload.id_cliente != null
        ) {
          listPayload.id_equipo = String(equipoPart.id_equipo);
        }
      } catch {}
      const list: any[] = await new Promise((resolve) => {
        try {
          if (!listPayload.participante_tipo) return resolve([]);
          sio.emit(
            "chat.list",
            {
              ...listPayload,
              include_participants: true,
              with_participants: true,
              includeParticipants: true,
              withParticipants: true,
            },
            (ack: any) => {
              const arr = Array.isArray(ack?.data) ? ack.data : [];
              try {
                console.log("[ensureChatReadyForSend] chat.list <=", {
                  payload: listPayload,
                  total: arr.length,
                });
              } catch {}
              resolve(arr);
            }
          );
        } catch {
          resolve([]);
        }
      });
      let matched: any | null = null;
      let subsetMatched: any | null = null;
      for (const it of list) {
        const parts = it?.participants || it?.participantes || [];
        const remoteSet = buildKeySetFromArray(parts);
        if (remoteSet.size > 0) {
          if (equalKeySets(desiredSet, remoteSet)) {
            matched = it;
            break;
          }
          if (!subsetMatched && isSubsetSet(desiredSet, remoteSet)) {
            subsetMatched = it;
          }
        }
      }
      if (!matched && subsetMatched) matched = subsetMatched;
      try {
        console.log("[ensureChatReadyForSend] resultado match =>", {
          matched: matched?.id_chat ?? matched?.id ?? null,
          via: matched
            ? equalKeySets(
                desiredSet,
                buildKeySetFromArray(
                  matched?.participants || matched?.participantes || []
                )
              )
              ? "equal"
              : "subset"
            : "none",
        });
      } catch {}
      // Fallback: si no hay participantes en el listado, probar unirse a los más recientes para leer participantes
      if (!matched && Array.isArray(list) && list.length > 0) {
        try {
          const sorted = [...list]
            .sort((a, b) => getItemTimestamp(b) - getItemTimestamp(a))
            .slice(0, 8);
          for (const it of sorted) {
            const id = it?.id_chat ?? it?.id;
            if (id == null) continue;
            const data = await probeJoin(id);
            if (!data) continue;
            const parts = data.participants || data.participantes || [];
            const remoteSet = buildKeySetFromArray(parts);
            if (remoteSet.size === 0) continue;
            const eq = equalKeySets(desiredSet, remoteSet);
            const sub = isSubsetSet(desiredSet, remoteSet);
            if (eq || sub) {
              // Confirmado: usar este chat y mapear mensajes inmediatamente
              const cid = data.id_chat ?? id;
              if (cid != null) setChatId(cid);
              if (data.my_participante)
                setMyParticipantId(data.my_participante);
              assignMyParticipantIdFromList(parts);
              const msgsSrc = Array.isArray(data.messages)
                ? data.messages
                : Array.isArray((data as any).mensajes)
                ? (data as any).mensajes
                : [];
              const otherRoleOnJoin: Sender = (() => {
                if (currentRole === "alumno") {
                  return socketio?.idEquipo != null ? "coach" : "admin";
                }
                if (currentRole === "coach") return "alumno";
                return "alumno";
              })();
              const mapped: Message[] = msgsSrc.map((m: any) => {
                const isMineById =
                  myParticipantId != null &&
                  String(m?.id_chat_participante_emisor ?? "") ===
                    String(myParticipantId);
                const tipoNorm = normalizeTipo(
                  m?.participante_tipo ||
                    getTipoByParticipantId(m?.id_chat_participante_emisor)
                );
                const isMineByTipo = (() => {
                  if (!tipoNorm) return false;
                  if (currentRole === "alumno") {
                    return (
                      tipoNorm === "cliente" &&
                      socketio?.idCliente != null &&
                      String(m?.id_cliente ?? "") ===
                        String(socketio?.idCliente)
                    );
                  }
                  if (currentRole === "coach") {
                    return (
                      tipoNorm === "equipo" &&
                      socketio?.idEquipo != null &&
                      String(m?.id_equipo ?? "") === String(socketio?.idEquipo)
                    );
                  }
                  return false;
                })();
                const senderFromTipo: Sender | null = (() => {
                  if (tipoNorm === "cliente") return "alumno";
                  if (tipoNorm === "equipo") return "coach";
                  return null;
                })();
                const sender: Sender = isMineById
                  ? currentRole
                  : isMineByTipo
                  ? currentRole
                  : senderFromTipo || otherRoleOnJoin;
                return {
                  id: String(m?.id_mensaje ?? `${Date.now()}-${Math.random()}`),
                  room: normRoom,
                  sender,
                  text: String(m?.Contenido ?? m?.contenido ?? ""),
                  at: String(m?.fecha_envio || new Date().toISOString()),
                  delivered: true,
                  read: !!m?.leido,
                  srcParticipantId: m?.id_chat_participante_emisor,
                  attachments: mapArchivoToAttachments(m),
                };
              });
              setItems(mapped);
              for (const mm of mapped) seenRef.current.add(mm.id);
              console.log(
                "[ensureChatReadyForSend] detectado existente via probeJoin <=",
                { id_chat: cid }
              );
              setIsJoining(false);
              creatingRef.current = false;
              return true;
            }
          }
        } catch {}
      }
      // Sin coincidencia exacta o por subconjunto: no reusar "más reciente"; proceder a crear.
      if (matched && matched.id_chat) {
        const joinPayload = { id_chat: matched.id_chat };
        joinedRef.current = true;
        const matchedParts =
          matched?.participants || matched?.participantes || [];
        return await new Promise<boolean>((resolve) => {
          try {
            sio.emit("chat.join", joinPayload, (ack: any) => {
              try {
                if (ack && ack.success) {
                  const data = ack.data || {};
                  const cid = data.id_chat ?? matched.id_chat;
                  if (cid != null) setChatId(cid);
                  if (data.my_participante)
                    setMyParticipantId(data.my_participante);
                  assignMyParticipantIdFromList(
                    data.participants || data.participantes || matchedParts
                  );
                  // Mapear mensajes cargados en el join
                  const msgsSrc = Array.isArray(data.messages)
                    ? data.messages
                    : Array.isArray((data as any).mensajes)
                    ? (data as any).mensajes
                    : [];
                  const otherRoleOnJoin: Sender = (() => {
                    if (currentRole === "alumno") {
                      return socketio?.idEquipo != null ? "coach" : "admin";
                    }
                    if (currentRole === "coach") return "alumno";
                    return "alumno";
                  })();
                  const mapped: Message[] = msgsSrc.map((m: any) => {
                    const isMineById =
                      myParticipantId != null &&
                      String(m?.id_chat_participante_emisor ?? "") ===
                        String(myParticipantId);
                    const tipoNorm = normalizeTipo(
                      m?.participante_tipo ||
                        getTipoByParticipantId(m?.id_chat_participante_emisor)
                    );
                    const isMineByTipo = (() => {
                      if (!tipoNorm) return false;
                      if (currentRole === "alumno") {
                        return (
                          tipoNorm === "cliente" &&
                          socketio?.idCliente != null &&
                          String(m?.id_cliente ?? "") ===
                            String(socketio?.idCliente)
                        );
                      }
                      if (currentRole === "coach") {
                        return (
                          tipoNorm === "equipo" &&
                          socketio?.idEquipo != null &&
                          String(m?.id_equipo ?? "") ===
                            String(socketio?.idEquipo)
                        );
                      }
                      return false;
                    })();
                    const senderFromTipo: Sender | null = (() => {
                      if (tipoNorm === "cliente") return "alumno";
                      if (tipoNorm === "equipo") return "coach";
                      return null;
                    })();
                    const sender: Sender = isMineById
                      ? currentRole
                      : isMineByTipo
                      ? currentRole
                      : senderFromTipo || otherRoleOnJoin;
                    return {
                      id: String(
                        m?.id_mensaje ?? `${Date.now()}-${Math.random()}`
                      ),
                      room: normRoom,
                      sender,
                      text: String(m?.Contenido ?? m?.contenido ?? ""),
                      at: String(m?.fecha_envio || new Date().toISOString()),
                      delivered: true,
                      read: !!m?.leido,
                      srcParticipantId: m?.id_chat_participante_emisor,
                      attachments: mapArchivoToAttachments(m),
                    };
                  });
                  setItems(mapped);
                  for (const mm of mapped) seenRef.current.add(mm.id);
                  try {
                    console.log("[ensureChatReadyForSend] join existente <=", {
                      id_chat: cid,
                      my_participante: data?.my_participante,
                      total_mensajes: mapped.length,
                    });
                  } catch {}
                  setIsJoining(false);
                  creatingRef.current = false;
                  // Actualizar listado en el padre para reflejar la conversación existente
                  refreshChatsList();
                  resolve(true);
                } else {
                  setIsJoining(false);
                  creatingRef.current = false;
                  resolve(false);
                }
              } catch {
                setIsJoining(false);
                creatingRef.current = false;
                resolve(false);
              }
            });
          } catch {
            setIsJoining(false);
            creatingRef.current = false;
            resolve(false);
          }
        });
      }
      // Crear
      return await new Promise<boolean>((resolve) => {
        try {
          sio.emit(
            "chat.create-with-participants",
            { participants },
            (ack: any) => {
              try {
                if (ack && ack.success && ack.data) {
                  const data = ack.data;
                  const cid =
                    data.id_chat ??
                    data.id ??
                    data?.chat?.id ??
                    ack?.id_chat ??
                    ack?.id ??
                    null;
                  if (cid != null) setChatId(cid);
                  const parts = data.participants || data.participantes;
                  assignMyParticipantIdFromList(parts);
                  try {
                    console.log("[ensureChatReadyForSend] creado chat", {
                      id_chat: cid,
                      participants: parts,
                    });
                  } catch {}
                  // Unir para obtener my_participante definitivo y mensajes
                  const finalizeWithJoin = (finalChatId: any) => {
                    try {
                      sio.emit(
                        "chat.join",
                        { id_chat: finalChatId },
                        (ackJoin: any) => {
                          try {
                            if (ackJoin && ackJoin.success) {
                              const dj = ackJoin.data || {};
                              if (dj.my_participante)
                                setMyParticipantId(dj.my_participante);
                              assignMyParticipantIdFromList(
                                dj.participants || dj.participantes || parts
                              );
                              console.log(
                                "[ensureChatReadyForSend] join tras crear <=",
                                {
                                  id_chat: finalChatId,
                                  my_participante: dj?.my_participante,
                                }
                              );
                            }
                          } catch {}
                        }
                      );
                    } catch {}
                  };
                  if (cid != null) {
                    finalizeWithJoin(cid);
                  } else {
                    // Fallback: si no vino id en el ack, intentar localizar con re-list por participantes
                    (async () => {
                      let found: any | null = null;
                      for (let i = 0; i < 3; i++) {
                        await new Promise((r) => setTimeout(r, 350));
                        const fresh: any[] = await new Promise((resolve2) => {
                          try {
                            sio.emit(
                              "chat.list",
                              {
                                ...listPayload,
                                include_participants: true,
                                with_participants: true,
                                includeParticipants: true,
                                withParticipants: true,
                              },
                              (ack2: any) => {
                                resolve2(
                                  Array.isArray(ack2?.data) ? ack2.data : []
                                );
                              }
                            );
                          } catch {
                            resolve2([]);
                          }
                        });
                        const desiredSet2 = buildKeySetFromArray(participants);
                        let matched2: any | null = null;
                        let subset2: any | null = null;
                        for (const it of fresh) {
                          const parts2 =
                            it?.participants || it?.participantes || [];
                          const remote2 = buildKeySetFromArray(parts2);
                          if (remote2.size === 0) continue;
                          if (equalKeySets(desiredSet2, remote2)) {
                            matched2 = it;
                            break;
                          }
                          if (!subset2 && isSubsetSet(desiredSet2, remote2))
                            subset2 = it;
                        }
                        found = matched2 || subset2 || null;
                        if (found && (found.id_chat || found.id)) break;
                      }
                      if (found && (found.id_chat || found.id)) {
                        const finalId = found.id_chat ?? found.id;
                        setChatId(finalId);
                        console.log(
                          "[ensureChatReadyForSend] CREATE fallback: localizado chatId",
                          { id_chat: finalId }
                        );
                        finalizeWithJoin(finalId);
                      } else {
                        console.warn(
                          "[ensureChatReadyForSend] CREATE fallback: no se pudo localizar el chat recién creado"
                        );
                      }
                    })();
                  }
                  try {
                    onChatInfo?.({
                      chatId: cid,
                      myParticipantId: myParticipantId,
                      participants: Array.isArray(parts) ? parts : null,
                    });
                  } catch {}
                  setIsJoining(false);
                  creatingRef.current = false;
                  // Refrescar listado para que el padre detecte el nuevo chat
                  refreshChatsList();
                  resolve(true);
                } else {
                  try {
                    console.warn("[ensureChatReadyForSend] CREATE fallo", ack);
                  } catch {}
                  setIsJoining(false);
                  creatingRef.current = false;
                  resolve(false);
                }
              } catch {
                setIsJoining(false);
                creatingRef.current = false;
                resolve(false);
              }
            }
          );
        } catch {
          setIsJoining(false);
          creatingRef.current = false;
          resolve(false);
        }
      });
    } catch {
      creatingRef.current = false;
      setIsJoining(false);
      return false;
    }
  }

  function fileFromAttachment(a: Attachment): File | null {
    try {
      const binary = atob(a.data_base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      const blob = new Blob([bytes], {
        type: a.mime || "application/octet-stream",
      });
      return new File([blob], a.name || "archivo", {
        type: a.mime || "application/octet-stream",
      });
    } catch {
      return null;
    }
  }

  // Marcar como leído (todo el chat) vía Socket.IO
  function markAllRead() {
    try {
      if (transport !== "socketio") return;
      const sio = sioRef.current;
      if (!sio || chatId == null) return;
      sio.emit("chat.read.all", { id_chat: chatId }, (ack: any) => {
        if (ack && !ack.success) {
          console.debug("read.all error:", ack.error);
        }
      });
      // Marca local (timestamp) para UI
      markRead();
    } catch {}
  }

  const sameDay = (a: Date, b: Date) =>
    a.getFullYear() === b.getFullYear() &&
    a.getMonth() === b.getMonth() &&
    a.getDate() === b.getDate();

  const enhanced = React.useMemo(() => {
    const out: Array<{
      key: string;
      type: "day" | "msg";
      day?: string;
      msg?: Message;
    }> = [];
    let lastDate: Date | null = null;
    for (const m of filteredItems) {
      const d = new Date(m.at);
      if (!lastDate || !sameDay(lastDate, d)) {
        out.push({
          key: `day-${d.toDateString()}`,
          type: "day",
          day: d.toLocaleDateString("es-ES"),
        });
        lastDate = d;
      }
      out.push({ key: m.id, type: "msg", msg: m });
    }
    return out;
  }, [filteredItems]);

  const [selectMode, setSelectMode] = React.useState(false);
  const [selectedIds, setSelectedIds] = React.useState<Set<string>>(new Set());
  function toggleSelect(id: string) {
    setSelectedIds((prev) => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id);
      else next.add(id);
      return next;
    });
  }
  const [selectedAttachmentIds, setSelectedAttachmentIds] = React.useState<
    Set<string>
  >(new Set());
  function toggleSelectAttachment(id: string) {
    setSelectedAttachmentIds((prev) => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id);
      else next.add(id);
      return next;
    });
  }

  function handleCreateTicketFromSelection() {
    const selected = items.filter((m) => selectedIds.has(m.id));
    const pickAttachments = () => {
      const list: Attachment[] = [];
      const hasGranular = selectedAttachmentIds.size > 0;
      selected.forEach((m) => {
        (m.attachments ?? []).forEach((a) => {
          if (!hasGranular || selectedAttachmentIds.has(a.id)) {
            list.push(a);
          }
        });
      });
      return list;
    };
    const atts = pickAttachments();

    // Generate suggested title from selected messages
    let suggested = "Ticket desde selección";
    const fromAlumno = [...selected]
      .reverse()
      .find((m) => m.sender === "alumno" && (m.text || "").trim());
    if (fromAlumno && fromAlumno.text) {
      suggested = String(fromAlumno.text).trim().slice(0, 120);
    }

    // Open modal with pre-filled data
    setTicketTitle(suggested);
    setTicketDescription(
      selected.map((m) => `[${m.sender}]: ${m.text}`).join("\n\n")
    );
    setTicketType("");
    setTicketAutoGenerated(false);
    setTicketSelectedMessages(selected);
    setTicketAttachments(atts);
    setTicketModalOpen(true);

    // Reset selection mode
    setSelectMode(false);
    setSelectedIds(new Set());
    setSelectedAttachmentIds(new Set());
  }

  function handleSubmitTicket() {
    if (!ticketTitle.trim()) {
      console.debug("El título es requerido");
      return;
    }

    if (!ticketType) {
      console.debug("El tipo de ticket es requerido");
      return;
    }

    const ticketData = {
      room: normRoom,
      title: ticketTitle,
      description: ticketDescription,
      type: ticketType,
      messages: ticketSelectedMessages,
      attachments: ticketAttachments,
      autoGenerated: ticketAutoGenerated,
      createdAt: new Date().toISOString(),
    };

    console.debug("Ticket creado:", ticketData);

    // Dispatch event for external handling if needed
    window.dispatchEvent(
      new CustomEvent("chat:ticket-created", { detail: ticketData })
    );

    // Close modal and reset
    setTicketModalOpen(false);
    setTicketTitle("");
    setTicketDescription("");
    setTicketType("");
    setTicketAutoGenerated(false);
    setTicketSelectedMessages([]);
    setTicketAttachments([]);
  }

  function formatFileSize(bytes: number): string {
    if (bytes < 1024) return bytes + " B";
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
    return (bytes / (1024 * 1024)).toFixed(1) + " MB";
  }

  const useFullscreen = isMobile || variant === "fullscreen";
  const containerBase = useFullscreen
    ? "flex flex-col w-full min-h-0 bg-[#efeae2]"
    : "rounded-lg border border-gray-300 bg-white overflow-hidden flex flex-col shadow-lg w-full min-h-0";

  const bgPatternStyle: React.CSSProperties = {
    backgroundColor: "#efeae2",
    backgroundImage:
      "url(\"data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fillRule='evenodd'%3E%3Cg fill='%23d9d9d9' fillOpacity='0.12'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E\")",
  };

  return (
    <>
      <div
        className={`${containerBase} ${className ?? ""}`}
        style={useFullscreen ? { height: "100%" } : undefined}
      >
        <div
          className="sticky top-0 z-10 flex-shrink-0 flex items-center justify-between px-3 sm:px-4 py-3 bg-[#075e54] text-white shadow"
          style={{
            paddingTop: useFullscreen
              ? "max(env(safe-area-inset-top), 12px)"
              : "12px",
          }}
        >
          <div className="flex items-center gap-3 flex-1 min-w-0">
            {onBack && useFullscreen && (
              <button
                onClick={onBack}
                className="mr-1 inline-flex h-9 w-9 items-center justify-center rounded-full hover:bg-white/10 active:scale-95"
                aria-label="Volver"
              >
                <ArrowLeft className="h-5 w-5" />
              </button>
            )}
            <div className="relative">
              <div className="w-10 h-10 rounded-full bg-[#128c7e] flex items-center justify-center text-white font-semibold text-sm border-2 border-white/20">
                {title.charAt(0).toUpperCase()}
              </div>
              {connected && (
                <span className="absolute bottom-0 right-0 h-3 w-3 rounded-full bg-[#25d366] border-2 border-[#075e54]" />
              )}
            </div>
            <div className="flex-1 min-w-0">
              <h3 className="text-base font-semibold text-white truncate">
                {title}
              </h3>
              <p className="text-xs text-white/80 truncate">
                {subtitle || (connected ? "en línea" : "desconectado")}
              </p>
            </div>
          </div>
          <div className="flex items-center gap-2">
            {showGenerateTicket && (
              <button
                title="Generar ticket (IA)"
                onClick={generateTicketFromRecent}
                className="p-2 rounded-full hover:bg-white/10 transition-colors flex items-center gap-2"
              >
                <Zap className="w-5 h-5" />
                <span className="hidden sm:inline text-sm font-medium">
                  Generar ticket
                </span>
              </button>
            )}
            {showFilter && (
              <Popover open={filterOpen} onOpenChange={setFilterOpen}>
                <PopoverTrigger asChild>
                  <button
                    className="p-2 rounded-full hover:bg-white/10 transition-colors"
                    title="Filtrar"
                  >
                    <Filter className="w-5 h-5" />
                    {(statusFilter || phaseFilter) && (
                      <span className="absolute -top-1 -right-1 bg-sky-500 text-white rounded-full w-4 h-4 text-xs flex items-center justify-center">
                        !
                      </span>
                    )}
                  </button>
                </PopoverTrigger>
                <PopoverContent className="w-56 p-4">
                  <div className="mb-2 text-sm font-semibold">
                    Filtrar mensajes
                  </div>
                  <div className="mb-2">
                    <div className="text-xs mb-1">Estatus</div>
                    <div className="flex flex-wrap gap-1">
                      {statusOptions.map((s) => (
                        <Badge
                          key={s}
                          variant={statusFilter === s ? "default" : "secondary"}
                          onClick={() =>
                            setStatusFilter(statusFilter === s ? null : s)
                          }
                          className="cursor-pointer"
                        >
                          {s.replace("_", " ")}
                        </Badge>
                      ))}
                    </div>
                  </div>
                  <div>
                    <div className="text-xs mb-1">Fase</div>
                    <div className="flex flex-wrap gap-1">
                      {phaseOptions.map((f) => (
                        <Badge
                          key={f}
                          variant={phaseFilter === f ? "default" : "secondary"}
                          onClick={() =>
                            setPhaseFilter(phaseFilter === f ? null : f)
                          }
                          className="cursor-pointer"
                        >
                          {f}
                        </Badge>
                      ))}
                    </div>
                  </div>
                  {(statusFilter || phaseFilter) && (
                    <button
                      className="mt-4 w-full text-xs text-sky-600 underline"
                      onClick={() => {
                        setStatusFilter(null);
                        setPhaseFilter(null);
                        setFilterOpen(false);
                      }}
                    >
                      Limpiar filtros
                    </button>
                  )}
                </PopoverContent>
              </Popover>
            )}
            {showSelect &&
              (selectMode ? (
                <button
                  onClick={() => {
                    setSelectMode(false);
                    setSelectedIds(new Set());
                  }}
                  className="px-2 py-1 rounded bg-white/10 text-xs"
                >
                  Cancelar
                </button>
              ) : (
                <button
                  onClick={() => setSelectMode(true)}
                  className="px-2 py-1 rounded bg-white/10 text-xs"
                  title="Seleccionar mensajes"
                >
                  Seleccionar
                </button>
              ))}
            {showRoleSwitch && (
              <select
                className="text-xs border border-white/30 rounded-md px-2 py-1 bg-white/10 text-white backdrop-blur-sm"
                value={currentRole}
                onChange={(e) => setCurrentRole(e.target.value as Sender)}
              >
                <option value="admin" className="text-gray-900">
                  Admin
                </option>
                <option value="alumno" className="text-gray-900">
                  Alumno
                </option>
                <option value="coach" className="text-gray-900">
                  Coach
                </option>
              </select>
            )}
            <button className="p-2 rounded-full hover:bg-white/10 transition-colors">
              <MoreVertical className="w-5 h-5" />
            </button>
          </div>
        </div>

        <div
          ref={scrollRef}
          onScroll={onScrollContainer}
          className="flex-1 overflow-y-auto p-4 space-y-2 min-h-0"
          style={bgPatternStyle}
        >
          {isJoining && (
            <div className="h-full flex items-center justify-center py-10">
              <div className="flex flex-col items-center gap-2 text-gray-600">
                <Spinner size={24} thickness={3} />
                <div className="text-xs">Cargando conversación…</div>
              </div>
            </div>
          )}
          {!isJoining && enhanced.length === 0 && (
            <div className="flex items-center justify-center h-full">
              <div className="text-center">
                <div className="w-20 h-20 mx-auto mb-4 rounded-full bg-white/50 flex items-center justify-center">
                  <svg
                    className="w-10 h-10 text-gray-400"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                  >
                    <path d="M2 5a2 2 0 012-2h7a2 2 0 012 2v4a2 2 0 01-2 2H9l-3 3v-3H4a2 2 0 01-2-2V5z" />
                    <path d="M15 7v2a4 4 0 01-4 4H9.828l-1.766 1.767c.28.149.599.233.938.233h2l3 3v-3h2a2 2 0 002-2V9a2 2 0 00-2-2h-1z" />
                  </svg>
                </div>
                <p className="text-sm text-gray-500 font-medium">
                  Sin mensajes aún
                </p>
                <p className="text-xs text-gray-400 mt-1">
                  {statusFilter || phaseFilter
                    ? "No hay mensajes que coincidan con el filtro."
                    : "Envía un mensaje para comenzar"}
                </p>
              </div>
            </div>
          )}
          {!isJoining &&
            enhanced.map((e) => {
              if (e.type === "day") {
                return (
                  <div
                    key={e.key}
                    className="flex items-center justify-center my-4"
                  >
                    <span className="text-xs px-3 py-1.5 rounded-lg bg-white/90 shadow-sm text-gray-600 font-medium">
                      {e.day}
                    </span>
                  </div>
                );
              }
              const m = e.msg!;
              const mine =
                (m.sender || "").toLowerCase() ===
                (currentRole || "").toLowerCase();
              return (
                <MessageBubble
                  key={e.key}
                  msg={{
                    id: m.id,
                    sender: m.sender as any,
                    text: m.text,
                    at: m.at,
                    attachments: m.attachments as any,
                    status: m.status,
                    delivered: m.delivered,
                    read: m.read,
                  }}
                  mine={mine}
                  selectMode={selectMode}
                  selected={selectedIds.has(m.id)}
                  onToggleSelect={() => toggleSelect(m.id)}
                  selectedAttachmentIds={selectedAttachmentIds}
                  onToggleSelectAttachment={toggleSelectAttachment}
                />
              );
            })}
          <div ref={bottomRef} />
        </div>

        <div
          className="p-2 bg-[#f0f0f0] border-t border-gray-200 flex-shrink-0"
          style={{ paddingBottom: "calc(env(safe-area-inset-bottom) + 8px)" }}
        >
          {showTypingIndicator && otherTyping && (
            <div className="px-3 pb-1 text-xs text-gray-600">
              El otro está escribiendo…
            </div>
          )}
          <div className="flex items-end gap-2">
            <button
              className="p-2.5 rounded-full hover:bg-gray-200 transition-colors active:scale-95"
              title="Emoji"
            >
              <Smile className="w-6 h-6 text-gray-600" />
            </button>
            <button
              onClick={onPickFiles}
              className="p-2.5 rounded-full hover:bg-gray-200 transition-colors active:scale-95"
              title="Adjuntar"
            >
              <Paperclip className="w-6 h-6 text-gray-600" />
            </button>
            <input
              ref={fileRef}
              type="file"
              multiple
              className="hidden"
              onChange={onFileInputChange}
            />
            <div className="flex-1">
              <textarea
                ref={inputRef}
                value={text}
                onChange={(e) => {
                  setText(e.target.value);
                  emitTyping(true);
                  try {
                    if (typingTimerRef.current)
                      clearTimeout(typingTimerRef.current);
                  } catch {}
                  typingTimerRef.current = setTimeout(
                    () => emitTyping(false),
                    1500
                  );
                }}
                onKeyDown={(e) => {
                  if (e.key === "Enter" && !e.shiftKey) {
                    e.preventDefault();
                    send();
                  }
                }}
                onInput={autoSize}
                placeholder="Escribe un mensaje"
                rows={1}
                className="w-full border-none rounded-3xl px-4 py-2.5 text-sm resize-none focus:outline-none bg-white shadow-sm max-h-40"
                style={{ minHeight: "42px" }}
              />
            </div>
            <button
              onClick={send}
              disabled={!text.trim() && pendingFiles.length === 0}
              className="p-2.5 rounded-full bg-[#25d366] text-white hover:bg-[#20bd5a] disabled:opacity-50 disabled:cursor-not-allowed transition-all active:scale-95 shadow-md"
              title="Enviar"
            >
              <Send className="w-5 h-5" />
            </button>
          </div>
          {pendingPreviews.length > 0 && (
            <div className="mt-2 grid grid-cols-3 gap-2">
              {pendingPreviews.map((p, i) => (
                <div key={`${p.url}-${i}`} className="relative group">
                  {p.type.startsWith("image/") ? (
                    <img
                      src={p.url || "/placeholder.svg"}
                      alt={p.name}
                      className="rounded-md max-h-32 object-cover w-full"
                    />
                  ) : p.type.startsWith("video/") ? (
                    <video
                      src={p.url}
                      className="rounded-md max-h-32 w-full"
                      controls
                    />
                  ) : p.type.startsWith("audio/") ? (
                    <audio src={p.url} className="w-full" controls />
                  ) : (
                    <a
                      href={p.url}
                      download={p.name}
                      className="text-xs underline break-all block p-2 bg-white rounded"
                    >
                      {p.name}
                    </a>
                  )}
                  <button
                    onClick={() => removePendingAt(i)}
                    className="absolute -top-2 -right-2 bg-gray-800 text-white rounded-full w-6 h-6 text-xs opacity-80 group-hover:opacity-100"
                    title="Quitar"
                  >
                    ×
                  </button>
                </div>
              ))}
            </div>
          )}
          {selectMode && selectedIds.size > 0 && (
            <div className="mt-2 flex justify-end">
              <button
                className="px-3 py-1.5 rounded bg-[#0ea5e9] text-white text-xs shadow hover:bg-[#0284c7] active:scale-95"
                onClick={handleCreateTicketFromSelection}
              >
                Crear ticket con selección
              </button>
            </div>
          )}
        </div>
      </div>

      <Dialog open={ticketModalOpen} onOpenChange={setTicketModalOpen}>
        <DialogContent className="sm:max-w-[600px] max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2 text-xl">
              <FileText className="w-5 h-5 text-gray-700" />
              Crear Ticket
              {ticketAutoGenerated && (
                <Badge variant="secondary" className="ml-2 gap-1">
                  <Sparkles className="w-3 h-3" />
                  IA
                </Badge>
              )}
            </DialogTitle>
            <DialogDescription className="text-sm text-gray-500">
              Completa la información del ticket para continuar
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4 py-4">
            {/* Ticket info badges */}
            <div className="flex items-center gap-2 flex-wrap">
              <Badge variant="outline" className="gap-1">
                <MessageSquare className="w-3 h-3" />
                {ticketSelectedMessages.length} mensajes
              </Badge>
              {ticketAttachments.length > 0 && (
                <Badge variant="outline" className="gap-1">
                  <Paperclip className="w-3 h-3" />
                  {ticketAttachments.length} archivos
                </Badge>
              )}
            </div>

            {/* Title field */}
            <div className="space-y-2">
              <label className="text-sm font-medium text-gray-700">
                Título <span className="text-red-500">*</span>
              </label>
              <input
                type="text"
                value={ticketTitle}
                onChange={(e) => setTicketTitle(e.target.value)}
                placeholder="Título del ticket"
                maxLength={120}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#075e54] focus:border-transparent text-sm"
              />
              <div className="text-xs text-gray-500 text-right">
                {ticketTitle.length}/120
              </div>
            </div>

            <div className="space-y-2">
              <label className="text-sm font-medium text-gray-700">
                Tipo <span className="text-red-500">*</span>
              </label>
              <Select
                value={ticketType}
                onValueChange={(value: string) => {
                  console.log("[v0] Select changed to:", value);
                  setTicketType(value as TicketType);
                }}
              >
                <SelectTrigger className="w-full">
                  <SelectValue placeholder="Selecciona un tipo" />
                </SelectTrigger>
                <SelectContent position="popper" className="z-[100]">
                  <SelectItem value="tecnico">Técnico</SelectItem>
                  <SelectItem value="academico">Académico</SelectItem>
                  <SelectItem value="administrativo">Administrativo</SelectItem>
                  <SelectItem value="soporte">Soporte</SelectItem>
                  <SelectItem value="consulta">Consulta</SelectItem>
                  <SelectItem value="otro">Otro</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Description field */}
            <div className="space-y-2">
              <label className="text-sm font-medium text-gray-700">
                Descripción
              </label>
              <textarea
                value={ticketDescription}
                onChange={(e) => setTicketDescription(e.target.value)}
                placeholder="Describe el problema o consulta..."
                rows={6}
                maxLength={2000}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#075e54] focus:border-transparent text-sm resize-none"
              />
              <div className="text-xs text-gray-500 text-right">
                {ticketDescription.length}/2000
              </div>
            </div>

            {ticketAttachments.length > 0 && (
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-700">
                  Archivos adjuntos ({ticketAttachments.length})
                </label>
                <div className="max-h-64 overflow-y-auto border border-gray-200 rounded-md p-3 bg-gray-50">
                  <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
                    {ticketAttachments.map((att) => {
                      const url = `data:${att.mime};base64,${att.data_base64}`;
                      const isImage = (att.mime || "").startsWith("image/");
                      const isVideo = (att.mime || "").startsWith("video/");
                      const isAudio = (att.mime || "").startsWith("audio/");

                      return (
                        <div
                          key={att.id}
                          className="relative group rounded-lg overflow-hidden border border-gray-300 bg-white shadow-sm hover:shadow-md transition-shadow"
                        >
                          {isImage && (
                            <div className="aspect-square">
                              <img
                                src={url || "/placeholder.svg"}
                                alt={att.name}
                                className="w-full h-full object-cover"
                              />
                            </div>
                          )}

                          {isVideo && (
                            <div className="aspect-square bg-gray-900">
                              <video
                                src={url}
                                className="w-full h-full object-cover"
                                preload="metadata"
                              />
                              <div className="absolute inset-0 flex items-center justify-center bg-black/30">
                                <div className="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
                                  <svg
                                    className="w-6 h-6 text-gray-800 ml-1"
                                    fill="currentColor"
                                    viewBox="0 0 20 20"
                                  >
                                    <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z" />
                                  </svg>
                                </div>
                              </div>
                            </div>
                          )}

                          {isAudio && (
                            <div className="p-4 flex flex-col items-center justify-center aspect-square bg-gradient-to-br from-purple-50 to-blue-50">
                              <svg
                                className="w-12 h-12 text-purple-600 mb-2"
                                fill="none"
                                stroke="currentColor"
                                viewBox="0 0 24 24"
                              >
                                <path
                                  strokeLinecap="round"
                                  strokeLinejoin="round"
                                  strokeWidth={2}
                                  d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"
                                />
                              </svg>
                            </div>
                          )}

                          {!isImage && !isVideo && !isAudio && (
                            <div className="p-4 flex flex-col items-center justify-center aspect-square bg-gradient-to-br from-gray-50 to-gray-100">
                              <svg
                                className="w-12 h-12 text-gray-400 mb-2"
                                fill="none"
                                stroke="currentColor"
                                viewBox="0 0 24 24"
                              >
                                <path
                                  strokeLinecap="round"
                                  strokeLinejoin="round"
                                  strokeWidth={2}
                                  d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"
                                />
                              </svg>
                              <span className="text-xs font-medium text-gray-500 uppercase">
                                {att.name.split(".").pop()?.slice(0, 4) ||
                                  "FILE"}
                              </span>
                            </div>
                          )}

                          <div className="p-2 bg-white border-t border-gray-200">
                            <p
                              className="text-xs font-medium text-gray-700 truncate"
                              title={att.name}
                            >
                              {att.name}
                            </p>
                            <p className="text-xs text-gray-500">
                              {formatFileSize(att.size)}
                            </p>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Actions */}
          <div className="flex items-center justify-end gap-3 pt-4 border-t">
            <button
              onClick={() => setTicketModalOpen(false)}
              className="px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 rounded-md transition-colors"
            >
              Cancelar
            </button>
            <button
              onClick={handleSubmitTicket}
              disabled={!ticketTitle.trim() || !ticketType}
              className="px-4 py-2 text-sm font-medium text-white bg-[#075e54] hover:bg-[#064e45] disabled:opacity-50 disabled:cursor-not-allowed rounded-md transition-colors"
            >
              Crear Ticket
            </button>
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
}
